<!-- title: Create BDD Tests -->
<!-- description: Create BDD tests using QuickPickle with proper world parameter usage -->

# BDD Test Creation Prompt

Create BDD tests for {{FEATURE}} following AuStdX patterns and QuickPickle conventions.

## Critical Requirements

### World Parameter Usage
**ALWAYS** use the world parameter as the first argument in step definitions:
```typescript
// ✅ CORRECT - Arrow function with world parameter
Given('I have a user account', (world: AuStdXBddWorld) => {
    world.user = createTestUser()
})

// ❌ WRONG - Never use 'this' context
Given('I have a user account', function() {
    this.user = createTestUser()  // DO NOT DO THIS
})
```

### Performance Targets
- Each scenario must execute in <1 second
- Step definitions should be optimized for speed
- Use test factories for quick data creation
- Minimize database operations where possible

## File Structure

Create these files:
```
test/features/
├── {{feature-name}}.feature         # Gherkin scenarios
└── step-definitions/
    └── {{feature-name}}.steps.ts    # Step implementations
```

## Feature File Template

```gherkin
# test/features/{{feature-name}}.feature
@{{feature-tag}}
Feature: {{Feature Title}}
  As a {{user type}}
  I want to {{action}}
  So that {{benefit}}

  Background:
    Given the application is running
    And test data is initialized

  @smoke @happy-path
  Scenario: {{Happy Path Scenario}}
    Given {{initial context}}
    When {{user action}}
    Then {{expected outcome}}
    And {{additional verification}}

  @edge-case
  Scenario: {{Edge Case Scenario}}
    Given {{edge case setup}}
    When {{edge action}}
    Then {{edge case outcome}}

  @error-handling
  Scenario: {{Error Scenario}}
    Given {{error condition setup}}
    When {{action that triggers error}}
    Then {{error is handled gracefully}}
    And {{user receives appropriate feedback}}

  @data-driven
  Scenario Outline: {{Data-Driven Scenario}}
    Given I have a <type> item
    When I perform <action>
    Then the result should be <expected>

    Examples:
      | type     | action  | expected |
      | standard | create  | success  |
      | premium  | create  | success  |
      | invalid  | create  | error    |
```

## Step Definitions Template

```typescript
// test/features/step-definitions/{{feature-name}}.steps.ts
import { Given, When, Then } from '@quickpickle/quickpickle'
import { expect } from 'vitest'
import { isNil, isEmpty } from 'lodash'
import type { AuStdXBddWorld } from '../support/world'

// Test data factories
import { createTestUser, createTestData } from '../factories'

// MSW handlers if needed
import { setupMockHandlers } from '../mocks/handlers'

Given('the application is running', (world: AuStdXBddWorld) => {
    // Setup initial application state
    world.app = initializeTestApp()
})

Given('test data is initialized', (world: AuStdXBddWorld) => {
    // Use factories for consistent test data
    world.testData = {
        users: [createTestUser(), createTestUser({ role: 'admin' })],
        items: createTestData('item', 5)
    }
})

When('I {string} a {string}', (world: AuStdXBddWorld, action: string, itemType: string) => {
    // Use Record pattern for action mapping
    const actionHandlers: Record<string, () => void> = {
        create: () => world.result = world.app.create(itemType),
        update: () => world.result = world.app.update(itemType, world.currentItem),
        delete: () => world.result = world.app.delete(world.currentItem.id)
    }
    
    const handler = actionHandlers[action]
    if (isNil(handler)) {
        throw new Error(`Unknown action: ${action}`)
    }
    
    handler()
})

Then('I should see {string}', (world: AuStdXBddWorld, expectedText: string) => {
    expect(world.page.content).toContain(expectedText)
})

Then('the operation completes in less than {int}ms', (world: AuStdXBddWorld, maxTime: number) => {
    expect(world.operationTime).toBeLessThan(maxTime)
})

// Parameterized steps for data tables
Then('the following data should exist:', (world: AuStdXBddWorld, dataTable: DataTable) => {
    const expectedData = dataTable.hashes()
    
    expectedData.forEach(row => {
        const actual = world.app.getData(row.id)
        expect(actual).toMatchObject(row)
    })
})
```

## World Class Extension

If needed, extend the base world class:

```typescript
// test/features/support/{{feature}}-world.ts
import { AuStdXBddWorld } from './world'

export class FeatureWorld extends AuStdXBddWorld {
    // Feature-specific properties
    currentItem?: Item
    operationTime?: number
    mockServer?: MockServer
    
    // Helper methods
    async setupFeatureContext() {
        this.mockServer = await setupMockServer()
        // Additional setup
    }
    
    async cleanupFeature() {
        await this.mockServer?.close()
        // Additional cleanup
    }
}
```

## Best Practices

### 1. Step Definition Patterns
- Keep steps focused and reusable
- Use parameterized steps for flexibility
- Avoid implementation details in step names
- Group related steps logically

### 2. Data Management
- Always use test factories for consistency
- Clean up test data after scenarios
- Use unique identifiers to avoid conflicts
- Mock external dependencies with MSW

### 3. Assertions
- Make assertions specific and clear
- Test both positive and negative cases
- Verify side effects when appropriate
- Use custom matchers for complex checks

### 4. Performance Optimization
```typescript
// Use BeforeAll for expensive setup
BeforeAll((world: AuStdXBddWorld) => {
    world.db = setupTestDatabase()
})

// Use Before for scenario-specific setup
Before((world: AuStdXBddWorld) => {
    world.resetState()
})

// Clean up in After hooks
After((world: AuStdXBddWorld) => {
    world.cleanup()
})
```

### 5. Common Patterns

#### Testing API Interactions
```typescript
Given('the API returns {string} for {string}', (world: AuStdXBddWorld, response: string, endpoint: string) => {
    world.mockHandlers.push(
        rest.get(`/api/${endpoint}`, (req, res, ctx) => {
            return res(ctx.json({ status: response }))
        })
    )
})
```

#### Testing UI States
```typescript
Then('the {string} component should be {string}', (world: AuStdXBddWorld, component: string, state: string) => {
    const stateCheckers: Record<string, () => boolean> = {
        visible: () => world.page.isVisible(component),
        hidden: () => !world.page.isVisible(component),
        disabled: () => world.page.isDisabled(component),
        loading: () => world.page.hasClass(component, 'loading')
    }
    
    expect(stateCheckers[state]()).toBe(true)
})
```

## Running Tests

```bash
# Run all BDD tests
pnpm test:bdd

# Run specific feature
pnpm test:bdd test/features/{{feature-name}}.feature

# Run with specific tags
pnpm test:bdd --tags @smoke
pnpm test:bdd --tags "@critical and not @slow"

# Generate Allure report
pnpm test:bdd && pnpm allure:generate
```

## Debugging Tips

1. Add `@debug` tag to focus on specific scenarios
2. Use `console.log` in world context for debugging
3. Take screenshots on failure:
   ```typescript
   After((world: AuStdXBddWorld) => {
       if (world.result.failed) {
           world.attach(await world.page.screenshot(), 'image/png')
       }
   })
   ```
4. Use step-through debugging with breakpoints

Remember: Clear, fast, and maintainable tests are the goal. Follow the patterns in existing tests and maintain consistency across the test suite!