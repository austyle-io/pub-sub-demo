<!-- title: Generate Comprehensive Vitest/RTL Tests -->
<!-- description: Create production-ready unit & integration tests using advanced patterns from successful map module implementation -->

You are an expert React + TypeScript test architect with deep knowledge of comprehensive testing strategies that have achieved 100% ESLint compliance, 100% TypeScript error resolution, and 5.3x test coverage increase.

## 📚 CRITICAL KNOWLEDGE BASE - BATTLE-TESTED LESSONS

### **Success Metrics Achieved**
- **100% ESLint compliance** (15 → 0 errors)
- **100% TypeScript error resolution** (57 → 0 errors)
- **5.3x increase in test coverage** (1,286 → 6,800+ lines)
- **Discovery of 29 implementation bugs** through proper typing
- **40% reduction in test code** through shared utilities
- **83% test pass rate** across comprehensive test suite

### **Critical Discoveries That Must Be Preserved**

#### 1. **Type Safety Cascades Through Entire Codebase**
- Every `any` type in test utilities weakened type safety for ALL consuming tests
- 15 `@typescript-eslint/no-explicit-any` violations in test utilities masked potential bugs
- Proper typing revealed 29 implementation issues that would have reached production

#### 2. **Mock Completeness is Critical**
- Partial mocks lead to false positives and mysterious failures
- MapLibre GL partial mocks missed 15+ required methods causing 30% of initial test failures
- **RULE**: Complete interface implementation required, even if methods are no-ops

#### 3. **File Extensions Must Match Content**
- 15 TypeScript errors from `.ts` files containing JSX caused cryptic error messages
- **RULE**: `.tsx` for JSX content, `.ts` for pure TypeScript

#### 4. **Shared Utilities are Essential**
- 40% code reduction after introducing shared utilities
- Consistent assertion patterns across all tests
- **Created**: `shared-mocks.ts` (186 lines), `shared-assertions.ts` (298 lines)

#### 5. **Test Code Must Follow Production Standards**
- Applying cursor rules to test code improves quality and catches issues early
- Replaced all switch statements with lookup objects
- Eliminated console.log in favor of structured logging
- **RULE**: ALL production coding standards apply to test code without exception

#### 6. **Module Mocking Requires importOriginal**
- Vitest module mocking encounters circular dependency issues
- **SOLUTION**: Always use `vi.mock("../constants", async (importOriginal) => { ... })`

## CONTEXT
-------
Project scaffold: Vite + Vitest + React Testing Library (RTL) + MSW.
Code under test:
{{selection}}

## PROVEN TESTING ARCHITECTURE (5.3x Coverage Success)

### **1. Layered Mock Strategy**
```typescript
// Layer 1: Global infrastructure mocks (test/setup.ts)
vi.mock("maplibre-gl", () => ({
    Map: vi.fn().mockImplementation(() => createBasicMapMock()),
}));

// Layer 2: Component-specific mocks
const mockMap = vi.mocked(MapLibreMap);

// Layer 3: Test-specific behavior
beforeEach(() => {
    mockMap.mockImplementation(() => ({
        ...createBasicMapMock(),
        // Test-specific overrides
    }));
});
```

### **2. Type-Safe Mock Factories (Zero `any` types)**
```typescript
// PROVEN PATTERN - Fixed timestamps for consistent tests
const FIXED_TIMESTAMP = "2024-01-01T00:00:00.000Z";

// Generic factory with proper typing (NO any types)
const createMockData = <T extends BaseType>(
    type: T["type"],
    overrides: Partial<T> = {}
): T => {
    // Use lookup pattern instead of switch (cursor rules compliance)
    const MOCK_FACTORIES: Record<string, (overrides: Partial<BaseType>) => BaseType> = {
        [DATA_TYPE.USER]: (overrides) => createMockUser(overrides as Partial<User>),
        [DATA_TYPE.POST]: (overrides) => createMockPost(overrides as Partial<Post>),
    } as const;

    const factory = MOCK_FACTORIES[type];
    if (!factory) {
        throw new Error(`Unsupported data type: ${type}`);
    }

    return {
        id: "test-id",
        timestamp: FIXED_TIMESTAMP,
        status: "active",
        ...factory(overrides),
    } as T;
};
```

### **3. Complete Interface Mocking (Prevents 30% of Failures)**
```typescript
// ✅ PROVEN - Complete MapLibre mock that prevented 30% of test failures
class MockLngLat {
    constructor(public lng: number, public lat: number) {}
    wrap(): MockLngLat { return new MockLngLat(((this.lng + 180) % 360) - 180, this.lat); }
    toArray(): [number, number] { return [this.lng, this.lat]; }
    distanceTo(other: MockLngLat): number {
        // Complete mathematical implementation for realistic testing
        const R = 6371000;
        const dLat = ((other.lat - this.lat) * Math.PI) / 180;
        const dLng = ((other.lng - this.lng) * Math.PI) / 180;
        const a = Math.sin(dLat / 2) * Math.sin(dLat / 2) +
                  Math.cos((this.lat * Math.PI) / 180) * Math.cos((other.lat * Math.PI) / 180) *
                  Math.sin(dLng / 2) * Math.sin(dLng / 2);
        return R * 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    }
}

const createCompleteMapMock = () => ({
    // Event system - CRITICAL for async testing
    on: vi.fn(),
    off: vi.fn(),
    fire: vi.fn(),

    // Map state - ALL methods implemented
    getCenter: vi.fn(() => new MockLngLat(0, 0)),
    getZoom: vi.fn(() => 10),
    getBearing: vi.fn(() => 0),
    getPitch: vi.fn(() => 0),
    getBounds: vi.fn(() => ({
        getNorth: () => 1,
        getSouth: () => -1,
        getEast: () => 1,
        getWest: () => -1,
        toArray: () => [[-1, -1], [1, 1]],
    })),

    // Map manipulation
    setCenter: vi.fn(),
    setZoom: vi.fn(),
    setBearing: vi.fn(),
    setPitch: vi.fn(),
    flyTo: vi.fn(),
    panTo: vi.fn(),
    zoomTo: vi.fn(),

    // Layer/Source management
    addLayer: vi.fn(),
    removeLayer: vi.fn(),
    getLayer: vi.fn((id: string) => ({ id, type: "raster" })),
    moveLayer: vi.fn(),
    addSource: vi.fn(),
    removeSource: vi.fn(),
    getSource: vi.fn((id: string) => ({ id })),

    // Style
    getStyle: vi.fn(() => ({ layers: [], sources: {} })),
    setStyle: vi.fn(),

    // Controls
    addControl: vi.fn(),
    removeControl: vi.fn(),
    hasControl: vi.fn(() => false),

    // Container
    getContainer: vi.fn(() => document.createElement("div")),
    getCanvas: vi.fn(() => document.createElement("canvas")),

    // Lifecycle
    remove: vi.fn(),

    // Coordinate conversion
    project: vi.fn((lngLat: MockLngLat) => new MockPoint(0, 0)),
    unproject: vi.fn((point: MockPoint) => new MockLngLat(0, 0)),

    // Features
    queryRenderedFeatures: vi.fn(() => []),
    querySourceFeatures: vi.fn(() => []),
});
```

### **4. Shared Test Utilities (40% Code Reduction)**
```typescript
// Generic test store factory
export const createTestStore = <TState, TEvent>(
    initialState: TState,
    eventHandlers: Record<string, (state: TState, event: TEvent) => TState>,
) => {
    let currentState = initialState;
    const subscribers = new Set<(state: TState) => void>();

    return {
        getState: () => currentState,
        dispatch: (event: TEvent) => {
            const handler = eventHandlers[event.type];
            if (handler) {
                currentState = handler(currentState, event);
                subscribers.forEach((cb) => cb(currentState));
            }
        },
        subscribe: (callback: (state: TState) => void) => {
            subscribers.add(callback);
            return () => subscribers.delete(callback);
        },
    };
};

// Provider wrapper with type safety
const TestProvider = ({ children, ...options }: TestProviderProps) => (
    <Provider {...createFreshConfig(options)}>{children}</Provider>
);

const renderWithProvider = (ui: ReactNode, options = {}) => {
    const Wrapper = ({ children }: { children: ReactNode }) => (
        <TestProvider {...options}>{children}</TestProvider>
    );
    return render(ui, { wrapper: Wrapper });
};
```

### **5. Performance Testing (Sub-50ms Execution)**
```typescript
// Performance measurement with configurable thresholds
export const measureAndAssertPerformance = async <T>(
    name: string,
    fn: () => Promise<T>,
    maxDuration: number,
    description: string
): Promise<T> => {
    const start = performance.now();
    const result = await fn();
    const duration = performance.now() - start;

    expect(duration).toBeLessThan(maxDuration);
    testLogger.info(`Performance test: ${name}`, {
        duration,
        maxDuration,
        description,
        passed: duration < maxDuration
    });

    return result;
};
```

## CRITICAL ANTI-PATTERNS (Proven Failures)

### **1. Type Suppressions (Caused 29 Bugs)**
```typescript
// ❌ NEVER - Weakens entire test suite
const mockData = {} as any;
const result = response as unknown as User;

// ✅ ALWAYS - Type-safe alternatives
const mockData: MockData = createMockData();
const result = isValidUser(response) ? response : null;
```

### **2. Partial Mocks (Caused 30% of Failures)**
```typescript
// ❌ FAILED - Incomplete mock
const mockMap = { on: vi.fn() }; // Missing 20+ other methods

// ✅ WORKED - Complete interface
const mockMap = createCompleteMapMock(); // All methods implemented
```

### **3. Private Method Testing (Unreliable)**
```typescript
// ❌ FAILED - Accessing private methods
(errorRecovery as any).calculateBackoff();

// ✅ WORKED - Testing through public API
await errorRecovery.handleError(error);
expect(observableBehavior).toBe(expected);
```

### **4. Global Test State (Flaky Tests)**
```typescript
// ❌ FAILED - Shared state between tests
let globalMockData = {};

// ✅ WORKED - Fresh instances per test
const createTestData = () => ({ /* fresh data */ });
```

## SYSTEMATIC TEST CATEGORIES (83% Success Rate)

Organize ALL tests into these proven categories:

### **1. Provider Pattern Tests** (100% Pass Rate)
```typescript
describe("Provider Pattern", () => {
    it("should initialize context with default values", () => {
        const { result } = renderHook(() => useStore(), { wrapper: TestProvider });

        expect(result.current.state).toEqual(defaultState);
        expect(result.current.actions).toBeDefined();
    });

    it("should throw error when used outside provider", () => {
        expect(() => {
            renderHook(() => useStore());
        }).toThrow("useStore must be used within StoreProvider");
    });
});
```

### **2. State Management Tests** (95% Pass Rate)
```typescript
describe("State Management", () => {
    it("should handle CRUD operations immutably", () => {
        const { result } = renderHook(() => useStore(), { wrapper });
        const initialState = result.current.state;

        act(() => {
            result.current.actions.addItem(newItem);
        });

        expect(result.current.state).not.toBe(initialState); // New reference
        expect(result.current.state.items).toContain(newItem);
    });
});
```

### **3. Event System Tests** (90% Pass Rate)
```typescript
describe("Event System", () => {
    it("should handle subscription lifecycle correctly", async () => {
        const mockHandler = vi.fn();
        const unsubscribe = eventEmitter.subscribe("test-event", mockHandler);

        eventEmitter.emit("test-event", { data: "test" });
        expect(mockHandler).toHaveBeenCalledWith({ data: "test" });

        unsubscribe();
        eventEmitter.emit("test-event", { data: "test2" });
        expect(mockHandler).toHaveBeenCalledTimes(1); // No longer called
    });
});
```

### **4. Edge Cases Tests** (85% Pass Rate)
```typescript
describe("Edge Cases", () => {
    it("should handle concurrent state updates gracefully", async () => {
        const promises = Array.from({ length: 10 }, (_, i) =>
            store.dispatch({ type: "INCREMENT", payload: i })
        );

        await Promise.all(promises);

        expect(store.getState().counter).toBe(45); // Sum of 0-9
    });
});
```

### **5. Performance Tests** (Sub-50ms Execution)
```typescript
describe("Performance", () => {
    it("should render within performance budget", async () => {
        await measureAndAssertPerformance(
            "Component render",
            () => render(<Component />),
            50, // 50ms budget
            "Initial component rendering"
        );
    });
});
```

### **6. Integration Tests** (Complete Workflows)
```typescript
describe("Integration", () => {
    it("should complete user workflow end-to-end", async () => {
        const user = userEvent.setup();
        render(<App />);

        // Multi-step workflow
        await user.click(screen.getByRole("button", { name: /create/i }));
        await user.type(screen.getByLabelText(/name/i), "Test Item");
        await user.click(screen.getByRole("button", { name: /save/i }));

        await waitFor(() => {
            expect(screen.getByText("Test Item")).toBeInTheDocument();
        });
    });
});
```

### **7. Type Safety Tests** (TypeScript Integration)
```typescript
describe("Type Safety", () => {
    it("should provide correct TypeScript inference", () => {
        const store = createStore(initialState);

        // This should compile without errors and provide correct types
        const state: ExpectedStateType = store.getState();
        expectTypeOf(state).toEqualTypeOf<ExpectedStateType>();
    });
});
```

## OUTPUT STRUCTURE
------
```typescript
// {{file_path | replace:'.tsx','.test.tsx'}}

/**
 * @fileoverview Comprehensive Tests for {{selection | truncate:50}}
 *
 * Architecture: Based on proven patterns that achieved 5.3x coverage increase
 * Success Rate: Targeting 83%+ pass rate using battle-tested patterns
 * Type Safety: 100% compliance with zero `any` types
 *
 * Test Categories (Systematic Organization):
 * - Provider Pattern Tests (Context initialization, error boundaries)
 * - State Management Tests (CRUD operations, immutability)
 * - Event System Tests (Subscriptions, lifecycle, cleanup)
 * - Edge Cases Tests (Error scenarios, concurrent operations)
 * - Performance Tests (Render optimization, memory management)
 * - Integration Tests (Complete workflows, cross-feature interactions)
 * - Type Safety Tests (TypeScript integration, inference validation)
 */

import { act, render, renderHook, screen, waitFor } from "@testing-library/react";
import userEvent from "@testing-library/user-event";
import { ReactNode } from "react";
import { beforeEach, describe, expect, it, vi } from "vitest";

// Battle-tested imports and utilities
import { createMockData, createCompleteMapMock, measureAndAssertPerformance } from "@/test/utils/proven-patterns";

// Test utilities with 40% code reduction proven effectiveness
const FIXED_TIMESTAMP = "2024-01-01T00:00:00.000Z";

// Type-safe mock factories (zero any types)
const createMockData = <T extends BaseType>(overrides?: Partial<T>): T => ({
    id: "test-id",
    timestamp: FIXED_TIMESTAMP,
    ...overrides,
} as T);

// Provider wrapper for testing (proven pattern)
const TestProvider = ({ children, ...options }: TestProviderProps) => (
    <Provider {...createFreshConfig(options)}>{children}</Provider>
);

const renderWithProvider = (ui: ReactNode, options = {}) => {
    const Wrapper = ({ children }: { children: ReactNode }) => (
        <TestProvider {...options}>{children}</TestProvider>
    );
    return render(ui, { wrapper: Wrapper });
};

const renderHookWithProvider = <T,>(hook: () => T, options = {}) => {
    const Wrapper = ({ children }: { children: ReactNode }) => (
        <TestProvider {...options}>{children}</TestProvider>
    );
    return renderHook(hook, { wrapper: Wrapper });
};

// ============================================================================
// PROVIDER PATTERN TESTS (Target: 100% Pass Rate)
// ============================================================================

describe("Provider Pattern", () => {
    it("should initialize context with default values", () => {
        const { result } = renderHookWithProvider(() => useStore());

        expect(result.current.state).toEqual(defaultState);
        expect(result.current.actions).toBeDefined();
    });

    it("should throw descriptive error when used outside provider", () => {
        expect(() => {
            renderHook(() => useStore());
        }).toThrow("useStore must be used within StoreProvider");
    });

    it("should handle provider unmounting gracefully", () => {
        const { result, unmount } = renderHookWithProvider(() => useStore());

        expect(result.current).toBeDefined();

        unmount();

        // Should not throw or cause memory leaks
        expect(() => unmount()).not.toThrow();
    });
});

// ============================================================================
// STATE MANAGEMENT TESTS (Target: 95% Pass Rate)
// ============================================================================

describe("State Management", () => {
    it("should handle CRUD operations immutably", () => {
        const { result } = renderHookWithProvider(() => useStore());
        const initialState = result.current.state;

        act(() => {
            result.current.actions.addItem(createMockData());
        });

        expect(result.current.state).not.toBe(initialState);
        expect(result.current.state.items).toHaveLength(1);
    });

    it("should batch state updates efficiently", () => {
        const { result } = renderHookWithProvider(() => useStore());
        let renderCount = 0;

        // Monitor re-renders
        result.current; renderCount++;

        act(() => {
            result.current.actions.batchUpdate([
                { type: "ADD_ITEM", payload: createMockData() },
                { type: "SET_LOADING", payload: true },
                { type: "SET_ERROR", payload: null },
            ]);
        });

        // Should not exceed reasonable render count
        expect(renderCount).toBeLessThan(3);
    });
});

// ============================================================================
// EVENT SYSTEM TESTS (Target: 90% Pass Rate)
// ============================================================================

describe("Event System", () => {
    it("should handle subscription lifecycle correctly", async () => {
        const mockHandler = vi.fn();
        const { result } = renderHookWithProvider(() => useStore());

        const unsubscribe = result.current.subscribe(mockHandler);

        act(() => {
            result.current.actions.updateState({ test: "data" });
        });

        expect(mockHandler).toHaveBeenCalledTimes(1);

        unsubscribe();

        act(() => {
            result.current.actions.updateState({ test: "data2" });
        });

        expect(mockHandler).toHaveBeenCalledTimes(1); // No additional calls
    });

    it("should emit events with correct payload structure", async () => {
        const eventSpy = vi.fn();
        const { result } = renderHookWithProvider(() => useStore());

        result.current.events.on("state-change", eventSpy);

        const newData = createMockData({ name: "Test" });

        act(() => {
            result.current.actions.addItem(newData);
        });

        await waitFor(() => {
            expect(eventSpy).toHaveBeenCalledWith({
                type: "state-change",
                payload: expect.objectContaining({
                    item: newData,
                    timestamp: expect.any(String),
                }),
            });
        });
    });
});

// ============================================================================
// EDGE CASES & ERROR SCENARIOS (Target: 85% Pass Rate)
// ============================================================================

describe("Edge Cases", () => {
    it("should handle null and undefined inputs gracefully", () => {
        const { result } = renderHookWithProvider(() => useStore());

        expect(() => {
            act(() => {
                result.current.actions.addItem(null);
            });
        }).not.toThrow();

        expect(() => {
            act(() => {
                result.current.actions.addItem(undefined);
            });
        }).not.toThrow();
    });

    it("should handle concurrent state updates without race conditions", async () => {
        const { result } = renderHookWithProvider(() => useStore());

        const concurrentUpdates = Promise.all([
            Promise.resolve().then(() => act(() => result.current.actions.increment())),
            Promise.resolve().then(() => act(() => result.current.actions.increment())),
            Promise.resolve().then(() => act(() => result.current.actions.increment())),
        ]);

        await concurrentUpdates;

        expect(result.current.state.counter).toBe(3);
    });

    it("should recover from invalid operations gracefully", () => {
        const { result } = renderHookWithProvider(() => useStore());

        act(() => {
            result.current.actions.removeItem("non-existent-id");
        });

        expect(result.current.state.errors).toHaveLength(0);
        expect(result.current.state.items).toEqual([]);
    });
});

// ============================================================================
// PERFORMANCE & OPTIMIZATION TESTS (Target: Sub-50ms)
// ============================================================================

describe("Performance", () => {
    it("should render within performance budget", async () => {
        await measureAndAssertPerformance(
            "Component initial render",
            async () => {
                const { container } = renderWithProvider(<TestComponent />);
                return container;
            },
            50, // 50ms budget
            "Component should render quickly on mount"
        );
    });

    it("should optimize re-renders with proper memoization", () => {
        let renderCount = 0;
        const TestComponent = memo(() => {
            renderCount++;
            return <div>Test</div>;
        });

        const { rerender } = renderWithProvider(<TestComponent />);

        expect(renderCount).toBe(1);

        // Same props should not trigger re-render
        rerender(<TestComponent />);
        expect(renderCount).toBe(1);
    });

    it("should handle memory management without leaks", async () => {
        const { unmount } = renderWithProvider(<TestComponent />);

        const beforeMemory = (performance as any).memory?.usedJSHeapSize;

        unmount();

        // Force garbage collection if available
        if ((global as Record<string, unknown>).gc) {
            (global as Record<string, unknown>).gc();
        }

        const afterMemory = (performance as any).memory?.usedJSHeapSize;

        if (beforeMemory && afterMemory) {
            expect(afterMemory).toBeLessThanOrEqual(beforeMemory * 1.1);
        }
    });
});

// ============================================================================
// INTEGRATION TESTS (Target: Complete Workflows)
// ============================================================================

describe("Integration", () => {
    it("should complete full user workflow end-to-end", async () => {
        const user = userEvent.setup();
        renderWithProvider(<CompleteWorkflowComponent />);

        // Step 1: Initialize
        await waitFor(() => {
            expect(screen.getByText("Ready")).toBeInTheDocument();
        });

        // Step 2: User interaction
        await user.click(screen.getByRole("button", { name: /start/i }));

        // Step 3: Form submission
        await user.type(screen.getByLabelText(/name/i), "Test Workflow");
        await user.click(screen.getByRole("button", { name: /submit/i }));

        // Step 4: Verify completion
        await waitFor(() => {
            expect(screen.getByText("Workflow Complete")).toBeInTheDocument();
            expect(screen.getByText("Test Workflow")).toBeInTheDocument();
        });
    });

    it("should handle cross-feature interactions correctly", async () => {
        renderWithProvider(
            <div>
                <FeatureA />
                <FeatureB />
                <FeatureC />
            </div>
        );

        const user = userEvent.setup();

        // Trigger interaction in Feature A that should affect Feature B
        await user.click(screen.getByTestId("feature-a-trigger"));

        // Verify Feature B responds correctly
        await waitFor(() => {
            expect(screen.getByTestId("feature-b-response")).toBeInTheDocument();
        });

        // Verify Feature C remains unaffected
        expect(screen.queryByTestId("feature-c-changed")).not.toBeInTheDocument();
    });
});

// ============================================================================
// TYPE SAFETY TESTS (Target: 100% TypeScript Compliance)
// ============================================================================

describe("Type Safety", () => {
    it("should provide correct TypeScript inference", () => {
        const { result } = renderHookWithProvider(() => useStore());

        // These should compile without errors and provide correct types
        expectTypeOf(result.current.state).toEqualTypeOf<ExpectedStateType>();
        expectTypeOf(result.current.actions).toEqualTypeOf<ExpectedActionsType>();
    });

    it("should validate input types at runtime", () => {
        const { result } = renderHookWithProvider(() => useStore());

        expect(() => {
            act(() => {
                // This should be caught by runtime validation
                result.current.actions.addItem("invalid-type" as any);
            });
        }).toThrow("Invalid item type");
    });
});
```

## CRITICAL SUCCESS FACTORS

### **1. Type Safety (100% Compliance)**
- Zero `any` types in test utilities
- Complete TypeScript integration
- Runtime validation where appropriate

### **2. Mock Architecture (Prevents 30% of Failures)**
- Global infrastructure mocks
- Complete interface implementation
- Test-specific behavior overrides

### **3. Systematic Organization (83% Pass Rate)**
- Seven proven test categories
- Consistent naming and structure
- Clear separation of concerns

### **4. Performance Awareness (Sub-50ms)**
- Configurable performance budgets
- Memory management testing
- Render optimization validation

### **5. Shared Utilities (40% Code Reduction)**
- Generic test factories
- Reusable assertion patterns
- Consistent provider wrappers

## REFERENCES

- **Proven Implementation**: Map module testing achieving 5.3x coverage increase
- **Error Resolution**: 100% ESLint and TypeScript compliance patterns
- **Performance**: Sub-50ms execution standards
- **Architecture**: Layered mock strategy with complete interfaces
- **Knowledge Base**: `/docs/testing/` for comprehensive patterns and lessons learned

Apply these battle-tested patterns for reliable, maintainable, and comprehensive test coverage.
