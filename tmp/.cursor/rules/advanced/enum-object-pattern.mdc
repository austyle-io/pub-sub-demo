---
description:
globs:
alwaysApply: true
---
# Enum-Object Pattern

Enforce literal-typed maps with lookup helpers and **STRICTLY FORBID** switch-case branching for option unions.

## ❌ **BANNED: Switch Statements**

**Switch statements are completely banned.** Use lookup objects with `Record<Option, T>` pattern instead.

**Reference Implementation**: See [type-guards.ts](mdc:src/lib/modules/map/utils/type-guards.ts) for real-world switch statement elimination.

## Required Pattern

### 1. Freeze Constant Map

Declare an UPPER_SNAKE_CASE object and append `as const`.

```typescript
export const OPTION = { FOO: "Foo", BAR: "Bar" } as const;
```

### 2. Derive Union Type

```typescript
export type Option = (typeof OPTION)[keyof typeof OPTION];
```

### 3. Materialize Runtime Array (ordered)

```typescript
import { values } from "lodash";
export const OPTIONS = values(OPTION) as Option[];
```

### 4. Lookup Helper Instead of Switch

Create a lookup object typed with `Record<Option, …>` and a helper that returns the mapped value.

```typescript
const LOOKUP: Record<Option, T> = {
  [OPTION.FOO]: /* … */,
  [OPTION.BAR]: /* … */,
};

export const getValue = (o: Option) => LOOKUP[o];
```

## Real-World Refactoring Example

### ❌ BEFORE: Switch Statement Violation

```typescript
// BAD - Switch statements in validation (from our codebase)
export const isValidSourceSpecification = (source: unknown): source is MapSourceConfig => {
    const result = MapSourceConfigSchema.safeParse(source);
    if (!result.success) return false;

    const validSource = result.data;

    // BANNED: Switch statement for validation
    switch (validSource.type) {
        case "geojson":
            return !isNil(validSource.data) &&
                (isString(validSource.data) ||
                    (isObject(validSource.data) && "type" in validSource.data));

        case "vector":
            return !isNil(validSource.url) || (isArray(validSource.tiles) && !isEmpty(validSource.tiles));

        case "raster":
            return (!isNil(validSource.url) || (isArray(validSource.tiles) && !isEmpty(validSource.tiles))) &&
                typeof validSource.tileSize === "number";

        case "image":
            return !isNil(validSource.url) && isArray(validSource.coordinates) && !isEmpty(validSource.coordinates);

        default:
            return false;
    }
};
```

### ✅ AFTER: Lookup Object Pattern

```typescript
// GOOD - Using Zod schema lookup (our final implementation)
import { MAP_SOURCE_TYPE } from "../constants";
import { MapSourceConfigSchema } from "../types/source-types";

/**
 * Validates if a MapSourceConfig can be safely converted to SourceSpecification.
 * Uses direct Zod schema validation instead of switch statements.
 */
export const isValidSourceSpecification = (source: unknown): source is MapSourceConfig => {
    return MapSourceConfigSchema.safeParse(source).success;
};

// The validation logic is now embedded in the Zod schemas themselves:
// GeoJSONSourceConfigSchema, VectorSourceConfigSchema, etc.
```

### Alternative Lookup Pattern (When Not Using Zod)

```typescript
// Lookup pattern for non-Zod scenarios
const SOURCE_TYPE_VALIDATORS: Record<string, (source: MapSourceConfig) => boolean> = {
    [MAP_SOURCE_TYPE.GEOJSON]: (source) => {
        const geoSource = source as any;
        return !isNil(geoSource.data) &&
            (isString(geoSource.data) ||
                (isObject(geoSource.data) && "type" in geoSource.data));
    },

    [MAP_SOURCE_TYPE.VECTOR]: (source) => {
        const vectorSource = source as any;
        return !isNil(vectorSource.url) || (isArray(vectorSource.tiles) && !isEmpty(vectorSource.tiles));
    },

    [MAP_SOURCE_TYPE.RASTER]: (source) => {
        const rasterSource = source as any;
        return (!isNil(rasterSource.url) || (isArray(rasterSource.tiles) && !isEmpty(rasterSource.tiles))) &&
            typeof rasterSource.tileSize === "number";
    },

    [MAP_SOURCE_TYPE.IMAGE]: (source) => {
        const imageSource = source as any;
        return !isNil(imageSource.url) && isArray(imageSource.coordinates) && !isEmpty(imageSource.coordinates);
    },
} as const;

const validateSourceByType = (source: MapSourceConfig): boolean => {
    const validator = SOURCE_TYPE_VALIDATORS[source.type];
    return validator ? validator(source) : false;
};
```

## Complete Example

```typescript
// Status enum-object
export const STATUS = {
    PENDING: "pending",
    IN_PROGRESS: "in_progress",
    COMPLETED: "completed",
    FAILED: "failed",
} as const;

export type Status = (typeof STATUS)[keyof typeof STATUS];

export const STATUSES = values(STATUS) as Status[];

// Lookup for status colors
const STATUS_COLORS: Record<Status, string> = {
    [STATUS.PENDING]: "yellow",
    [STATUS.IN_PROGRESS]: "blue",
    [STATUS.COMPLETED]: "green",
    [STATUS.FAILED]: "red",
};

export const getStatusColor = (status: Status) => STATUS_COLORS[status];

// Lookup for status labels
const STATUS_LABELS: Record<Status, string> = {
    [STATUS.PENDING]: "Waiting to start",
    [STATUS.IN_PROGRESS]: "Currently running",
    [STATUS.COMPLETED]: "Successfully finished",
    [STATUS.FAILED]: "Encountered an error",
};

export const getStatusLabel = (status: Status) => STATUS_LABELS[status];
```

## Validation Lookup Patterns

### Complex Validation with Lookup

```typescript
// Layer validation using lookup pattern (from our implementation)
const LAYER_TYPE_VALIDATORS: Record<string, (layer: MapLayerConfig) => boolean> = {
    background: (layer) => isNil(layer.source), // Background layers don't need source
} as const;

const validateLayerByType = (layer: MapLayerConfig): boolean => {
    const validator = LAYER_TYPE_VALIDATORS[layer.type];
    // Default validation for non-background layers
    return validator ? validator(layer) : (!isNil(layer.source) && isString(layer.source));
};

// Usage in main validation function
export const isValidLayerSpecification = (layer: unknown): layer is MapLayerConfig => {
    const result = MapLayerConfigSchema.safeParse(layer);
    if (!result.success) return false;

    const validLayer = result.data;
    return validateLayerByType(validLayer); // Uses lookup, not switch
};
```

### Performance-Critical Lookups

```typescript
// Performance lookup for frequently called operations
const HTTP_STATUS_VALIDATORS: Record<number, () => boolean> = {
    200: () => true,
    201: () => true,
    204: () => true,
    400: () => false,
    401: () => false,
    403: () => false,
    404: () => false,
    500: () => false,
} as const;

const isSuccessStatus = (status: number): boolean => {
    const validator = HTTP_STATUS_VALIDATORS[status];
    return validator ? validator() : false; // O(1) lookup vs O(n) switch
};
```

## Anti-Patterns (Forbidden)

### ❌ Switch Statements

```typescript
// BAD - switch statement
const getStatusColor = (status: Status) => {
    switch (status) {
        case STATUS.PENDING:
            return "yellow";
        case STATUS.IN_PROGRESS:
            return "blue";
        case STATUS.COMPLETED:
            return "green";
        case STATUS.FAILED:
            return "red";
        default:
            return "gray";
    }
};
```

### ❌ If-Else Chains

```typescript
// BAD - if-else chain
const getStatusColor = (status: Status) => {
    if (status === STATUS.PENDING) return "yellow";
    if (status === STATUS.IN_PROGRESS) return "blue";
    if (status === STATUS.COMPLETED) return "green";
    if (status === STATUS.FAILED) return "red";
    return "gray";
};
```

### ❌ Nested Switch Statements

```typescript
// BAD - nested switches (especially bad)
const processRequest = (type: RequestType, status: Status) => {
    switch (type) {
        case "API":
            switch (status) {
                case STATUS.PENDING:
                    return handleApiPending();
                case STATUS.COMPLETED:
                    return handleApiCompleted();
                default:
                    return handleApiError();
            }
        case "DATABASE":
            switch (status) {
                case STATUS.PENDING:
                    return handleDbPending();
                case STATUS.COMPLETED:
                    return handleDbCompleted();
                default:
                    return handleDbError();
            }
        default:
            return handleUnknown();
    }
};
```

### ✅ Lookup Alternative for Nested Logic

```typescript
// GOOD - nested lookup pattern
const REQUEST_HANDLERS: Record<RequestType, Record<Status, () => any>> = {
    API: {
        [STATUS.PENDING]: handleApiPending,
        [STATUS.COMPLETED]: handleApiCompleted,
        [STATUS.FAILED]: handleApiError,
    },
    DATABASE: {
        [STATUS.PENDING]: handleDbPending,
        [STATUS.COMPLETED]: handleDbCompleted,
        [STATUS.FAILED]: handleDbError,
    },
} as const;

const processRequest = (type: RequestType, status: Status) => {
    const handler = REQUEST_HANDLERS[type]?.[status] ?? handleUnknown;
    return handler();
};
```

## Migration Strategy

### Step 1: Identify Switch Statements

```bash
# Find all switch statements in your codebase
grep -r "switch\s*(" src/ --include="*.ts" --include="*.tsx"
```

### Step 2: Extract Constants

```typescript
// Before
switch (userType) {
    case "admin":
        return "Administrator";
    case "user":
        return "Regular User";
}

// After - Step 1: Extract constants
const USER_TYPE = {
    ADMIN: "admin",
    USER: "user",
} as const;
```

### Step 3: Create Lookup Object

```typescript
// Step 2: Create lookup
const USER_TYPE_LABELS: Record<UserType, string> = {
    [USER_TYPE.ADMIN]: "Administrator",
    [USER_TYPE.USER]: "Regular User",
} as const;
```

### Step 4: Replace Switch with Lookup

```typescript
// Step 3: Replace switch
const getUserTypeLabel = (userType: UserType): string => {
    return USER_TYPE_LABELS[userType] ?? "Unknown";
};
```

## Benefits

- **Declarative**: Logic is data, not control flow
- **Exhaustive**: TypeScript ensures all cases are handled
- **Maintainable**: Adding new options requires updating lookup objects
- **Performance**: O(1) lookup vs O(n) conditional checks
- **Testable**: Easy to test lookup objects vs complex control flow
- **Type-Safe**: Compile-time verification of completeness
- **Debuggable**: Clear separation between data and logic
- **Refactorable**: Easy to extract and move lookup objects

## Advanced Usage

### Multiple Lookups

```typescript
export const PRIORITY = {
    LOW: "low",
    MEDIUM: "medium",
    HIGH: "high",
    CRITICAL: "critical",
} as const;

export type Priority = (typeof PRIORITY)[keyof typeof PRIORITY];

// Multiple lookup helpers
const PRIORITY_COLORS: Record<Priority, string> = {
    [PRIORITY.LOW]: "gray",
    [PRIORITY.MEDIUM]: "blue",
    [PRIORITY.HIGH]: "orange",
    [PRIORITY.CRITICAL]: "red",
};

const PRIORITY_WEIGHTS: Record<Priority, number> = {
    [PRIORITY.LOW]: 1,
    [PRIORITY.MEDIUM]: 2,
    [PRIORITY.HIGH]: 3,
    [PRIORITY.CRITICAL]: 4,
};

export const getPriorityColor = (priority: Priority) => PRIORITY_COLORS[priority];
export const getPriorityWeight = (priority: Priority) => PRIORITY_WEIGHTS[priority];
```

### Function Lookup for Complex Logic

```typescript
const VALIDATION_HANDLERS: Record<ValidationRule, (value: any) => boolean> = {
    required: (value) => !isNil(value) && !isEmpty(value),
    email: (value) => isString(value) && value.includes("@"),
    number: (value) => isNumber(value) && !isNaN(value),
    positive: (value) => isNumber(value) && value > 0,
} as const;

const validate = (value: any, rule: ValidationRule): boolean => {
    const handler = VALIDATION_HANDLERS[rule];
    return handler ? handler(value) : false;
};
```
