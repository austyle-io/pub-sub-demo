---
description:
globs:
alwaysApply: true
---

# ClassNames Prop Pattern

Enforce standardized `classNames` prop object on React components with `<elementName>ClassName?: ClassValue` entries.

## Required Pattern for Component Props

Whenever you define props for a React component (via `type`), include an optional `classNames` object with these keys and types:

```typescript
type ComponentProps = {
    // Other props...
    title: string;
    onClick?: () => void;

    // Required classNames prop structure
    classNames?: {
        containerClassName?: ClassValue;
        labelClassName?: ClassValue;
        inputClassName?: ClassValue;
        messageClassName?: ClassValue;
        adornmentClassName?: ClassValue;
    };
};
```

## Rules

- **Prop name**: must be exactly `classNames`
- **Key naming**: each key is `<elementName>ClassName` (camelCase element + `ClassName`)
- **Value type**: all entries must be `ClassValue` (not `string` or other)

## Complete Example

```typescript
import type { ClassValue } from 'clsx';

type InputFieldProps = {
  label: string;
  value: string;
  onChange: (value: string) => void;
  error?: string;
  placeholder?: string;
  classNames?: {
    containerClassName?: ClassValue;
    labelClassName?: ClassValue;
    inputClassName?: ClassValue;
    errorClassName?: ClassValue;
    helperClassName?: ClassValue;
  };
};

export const InputField = ({
  label,
  value,
  onChange,
  error,
  placeholder,
  classNames,
}: InputFieldProps) => {
  return (
    <div className={clsx('field-container', classNames?.containerClassName)}>
      <label className={clsx('field-label', classNames?.labelClassName)}>
        {label}
      </label>

      <input
        type="text"
        value={value}
        onChange={(e) => onChange(e.target.value)}
        placeholder={placeholder}
        className={clsx(
          'field-input',
          error && 'field-input--error',
          classNames?.inputClassName
        )}
      />

      {error && (
        <span className={clsx('field-error', classNames?.errorClassName)}>
          {error}
        </span>
      )}
    </div>
  );
};
```

## Usage

```typescript
const MyForm = () => {
  return (
    <InputField
      label="Email"
      value={email}
      onChange={setEmail}
      classNames={{
        containerClassName: "mb-4",
        labelClassName: "font-semibold text-gray-700",
        inputClassName: "border-2 rounded-lg px-3 py-2",
        errorClassName: "text-red-500 text-sm",
      }}
    />
  );
};
```

## Standard Element Names

Use consistent naming for common UI elements:

- `containerClassName` - Main wrapper element
- `labelClassName` - Text labels
- `inputClassName` - Form inputs
- `buttonClassName` - Buttons and clickable elements
- `iconClassName` - Icons and visual indicators
- `messageClassName` - Status/helper messages
- `errorClassName` - Error messages
- `contentClassName` - Main content areas
- `headerClassName` - Header sections
- `footerClassName` - Footer sections
- `itemClassName` - List or grid items
- `adornmentClassName` - Decorative elements

## Anti-Patterns

### ❌ Separate Top-Level Props

```typescript
// BAD - separate className props at top level
type BadProps = {
    title: string;
    containerClassName?: string; // BAD
    labelClassName?: string; // BAD
    inputClassName?: string; // BAD
};
```

### ❌ Wrong Type

```typescript
// BAD - using string instead of ClassValue
type BadProps = {
    classNames?: {
        containerClassName?: string; // BAD
        labelClassName?: string[]; // BAD
        inputClassName?: TailwindClass; // BAD
    };
};
```

### ❌ Missing Standard Keys

```typescript
// BAD - inconsistent naming
type BadProps = {
    classNames?: {
        wrapper?: ClassValue; // BAD - should be containerClassName
        title?: ClassValue; // BAD - should be labelClassName
        field?: ClassValue; // BAD - should be inputClassName
    };
};
```

## Benefits

- **Consistency**: All components follow same pattern
- **Flexibility**: Consumers can style any element
- **Type Safety**: ClassValue type ensures compatibility with clsx/classnames
- **Discoverability**: Standard element names are predictable
- **Composability**: Easy to build design systems with consistent override patterns
