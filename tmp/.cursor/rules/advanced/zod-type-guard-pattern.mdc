---
description:
globs:
alwaysApply: true
---
# Zod Type Guard Pattern

Comprehensive rules for implementing type-safe type guards using Zod validation and runtime type checking with **Zod schemas as the source of truth**.

## Rules

### 1. Zod-First Schema Approach (Preferred)

- **Define Zod schemas as the source of truth** and derive TypeScript types using `z.infer<typeof Schema>`.
- **Reference Implementation**: [source-types.ts](mdc:src/lib/modules/map/types/source-types.ts) and [type-guards.ts](mdc:src/lib/modules/map/utils/type-guards.ts)
- **Example:**

    ```ts
    import { z } from "zod";

    // Schema is the source of truth
    export const UserSchema = z.object({
        id: z.string(),
        name: z.string(),
        email: z.string().email(),
        role: z.enum(["admin", "user", "moderator"]),
        createdAt: z.string().datetime(),
    });

    // Type derived from schema
    export type User = z.infer<typeof UserSchema>;

    /**
     * Validates if the input is a valid User object from the API.
     * Uses the schema directly for validation.
     */
    export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;
    ```

### 2. Union Schema Validation

- For discriminated unions, use `z.union()` with individual schemas and direct validation.
- **Example from our implementation:**

    ```ts
    // Individual schemas
    export const GeoJSONSourceConfigSchema = z.object({
        id: z.string(),
        type: z.literal("geojson"),
        data: z.union([z.string(), z.object({ type: z.string() })]),
        // ... other properties
    });

    export const VectorSourceConfigSchema = z.object({
        id: z.string(),
        type: z.literal("vector"),
        url: z.string().optional(),
        tiles: z.array(z.string()).optional(),
        // ... other properties
    }).refine((data) => !!(data.url || data.tiles?.length), {
        message: "Vector source must have either url or tiles",
    });

    // Union schema
    export const MapSourceConfigSchema = z.union([
        GeoJSONSourceConfigSchema,
        VectorSourceConfigSchema,
        // ... other source schemas
    ]);

    // Derived union type
    export type MapSourceConfig = z.infer<typeof MapSourceConfigSchema>;

    // Simple validation using union schema
    export const isValidSourceSpecification = (source: unknown): source is MapSourceConfig => {
        return MapSourceConfigSchema.safeParse(source).success;
    };
    ```

### 3. Use `.safeParse`, Not `.parse`

- Use `.safeParse` in all guards to avoid runtime exceptions and side effects.
- **Example:**

    ```ts
    // ✅ GOOD - Use safeParse
    export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;

    // ❌ BAD - Don't use parse (throws exceptions)
    export const isUser = (x: unknown): x is User => {
        try {
            UserSchema.parse(x);
            return true;
        } catch {
            return false;
        }
    };
    ```

### 4. Naming Convention

- Type guard functions **must** be named with the `isX` prefix matching the type.
- **Example:**

    ```ts
    export type User = z.infer<typeof UserSchema>;
    export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;

    export type ApiResponse = z.infer<typeof ApiResponseSchema>;
    export const isApiResponse = (x: unknown): x is ApiResponse => ApiResponseSchema.safeParse(x).success;
    ```

### 5. Use Zod for All Data Validation Except When Dependencies Provide Validators

- **Use Zod for all external data validation** (API responses, user input, file parsing) unless a dependency already provides type guards or validators
- **Use dependency-provided validators** when available (e.g., React Hook Form validators, third-party library type guards)
- **Use Lodash for simple type checking** in utility functions, not data validation
- **Example:**

    ```ts
    import { isString, isNumber } from "lodash";

    // ✅ GOOD - Zod for external data validation
    const ApiUserSchema = z.object({
        id: z.string(),
        name: z.string(),
        email: z.string().email(),
    });

    export const isApiUser = (data: unknown): data is ApiUser =>
        ApiUserSchema.safeParse(data).success;

    // ✅ GOOD - Use dependency validators when available
    import { isValidEmail } from "validator"; // Third-party library
    export const validateEmailField = (email: string) => isValidEmail(email);

    // ✅ GOOD - Lodash for simple utility type checking (not validation)
    export const isStringArray = (val: unknown): val is string[] =>
        Array.isArray(val) && val.every(isString);

    // ❌ BAD - Manual validation when Zod should be used
    export const isUser = (data: unknown): data is User => {
        return typeof data === "object" && data !== null && "id" in data;
    };
    ```

### 6. Co-locate Schema, Type, and Guard

- Keep the Zod schema, TypeScript type, and guard function together in the same file/module.
- **Reference**: [source-types.ts](mdc:src/lib/modules/map/types/source-types.ts) for schema-first organization
- **Example:**

    ```ts
    // user-types.ts
    import { z } from "zod";

    export const UserSchema = z.object({
        id: z.string(),
        name: z.string(),
        email: z.string().email(),
        role: z.enum(["admin", "user", "moderator"]),
        createdAt: z.string().datetime(),
    });

    export type User = z.infer<typeof UserSchema>;

    /**
     * Validates if the input is a valid User object from the API.
     * Used at trust boundaries for type safety.
     */
    export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;
    ```

### 7. No Type Assertions in Guards

- Never use `as Type` or `!!` to assert types inside type guards.
- **Example:**

    ```ts
    // ✅ GOOD - Proper validation
    export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;

    // ❌ BAD - Type assertions
    export const isUser = (x: unknown): x is User => {
        return !!(x as User).id; // BAD - unsafe assertion
    };

    // ❌ BAD - Duck typing
    export const isUser = (x: unknown): x is User => {
        return typeof x === "object" && x !== null && "id" in x; // BAD - incomplete validation
    };
    ```

### 8. Require Docstrings for All Guards

- Each type guard **must** include a docstring describing its trust boundary or purpose.
- **Example:**

    ```ts
    /**
     * Validates if the input is a valid User object from the API.
     * Used at API response boundaries to ensure type safety.
     */
    export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;

    /**
     * Validates if the input is a valid form submission for creating a user.
     * Used for client-side form validation before API calls.
     */
    export const isCreateUserRequest = (x: unknown): x is CreateUserRequest =>
        CreateUserRequestSchema.safeParse(x).success;
    ```

## Schema Refinement Patterns

### Complex Validation with `.refine()`

```ts
export const VectorSourceConfigSchema = z.object({
    id: z.string(),
    type: z.literal("vector"),
    url: z.string().optional(),
    tiles: z.array(z.string()).optional(),
    attribution: z.string().optional(),
}).refine((data) => !!(data.url || data.tiles?.length), {
    message: "Vector source must have either url or tiles",
});
```

### Transformation with `.transform()`

```ts
const TimestampSchema = z.string().transform((val) => new Date(val));

const UserWithDatesSchema = z.object({
    id: z.string(),
    name: z.string(),
    createdAt: TimestampSchema,
    updatedAt: TimestampSchema,
});

export type UserWithDates = z.infer<typeof UserWithDatesSchema>;

/**
 * Validates and transforms API user data with date parsing.
 * Converts ISO string dates to Date objects.
 */
export const parseUserWithDates = (x: unknown): UserWithDates | null => {
    const result = UserWithDatesSchema.safeParse(x);
    return result.success ? result.data : null;
};
```

## Advanced Patterns

### Union Type Guards

```ts
import { z } from "zod";

const SuccessResponseSchema = z.object({
    success: z.literal(true),
    data: z.unknown(),
});

const ErrorResponseSchema = z.object({
    success: z.literal(false),
    error: z.string(),
    code: z.string().optional(),
});

const ApiResponseSchema = z.union([SuccessResponseSchema, ErrorResponseSchema]);

export type ApiResponse = z.infer<typeof ApiResponseSchema>;
export type SuccessResponse = z.infer<typeof SuccessResponseSchema>;
export type ErrorResponse = z.infer<typeof ErrorResponseSchema>;

/**
 * Validates if the input is a valid API response (success or error).
 */
export const isApiResponse = (x: unknown): x is ApiResponse => ApiResponseSchema.safeParse(x).success;

/**
 * Validates if the API response represents a successful operation.
 */
export const isSuccessResponse = (x: unknown): x is SuccessResponse => SuccessResponseSchema.safeParse(x).success;

/**
 * Validates if the API response represents an error.
 */
export const isErrorResponse = (x: unknown): x is ErrorResponse => ErrorResponseSchema.safeParse(x).success;
```

## Anti-Patterns

```ts
// ❌ BAD - Manual type checking without schema validation
export const isUser = (x: unknown): x is User => {
    return typeof x === "object" && x !== null && "id" in x && "name" in x;
};

// ❌ BAD - Using type assertions
export const isUser = (x: unknown): x is User => {
    return !!(x as User).id;
};

// ❌ BAD - Using .parse instead of .safeParse
export const isUser = (x: unknown): x is User => {
    try {
        UserSchema.parse(x);
        return true;
    } catch {
        return false;
    }
};

// ❌ BAD - Missing docstring
export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;

// ❌ BAD - Inconsistent naming
export const validateUser = (x: unknown): x is User => UserSchema.safeParse(x).success; // Should be isUser

// ❌ BAD - TypeScript-first approach (creates drift risk)
export type User = {
    id: string;
    name: string;
    email: string;
};

const UserSchema = z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email(), // Different validation than type!
});
```

## Migration from TypeScript-First to Zod-First

When converting existing TypeScript types to Zod-first:

1. **Create Zod schema first**: Define the schema with validation rules
2. **Replace type definition**: Use `z.infer<typeof Schema>` instead of manual type definition
3. **Update type guards**: Use schema directly instead of manual validation
4. **Add refinements**: Include business logic validation in the schema
5. **Test thoroughly**: Ensure validation behavior matches expectations

```ts
// Before (TypeScript-first)
export type User = {
    id: string;
    name: string;
    email: string;
};

export const isUser = (x: unknown): x is User => {
    return typeof x === "object" && x !== null && "id" in x && "name" in x && "email" in x;
};

// After (Zod-first)
export const UserSchema = z.object({
    id: z.string(),
    name: z.string(),
    email: z.string().email(),
});

export type User = z.infer<typeof UserSchema>;

export const isUser = (x: unknown): x is User => UserSchema.safeParse(x).success;
```

## Quick Reference Table

| Scenario                                  | Approach            | Example                                       |
| ----------------------------------------- | ------------------- | --------------------------------------------- |
| Complex data shape / API boundary         | zod schema + infer  | `const Schema = z.object({...}); type T = z.infer<typeof Schema>` |
| Primitive or trivial (e.g., string array) | lodash + TS guard   | `isStringArray(x: unknown): x is string[]`    |
| Union types                               | zod union + guard   | `z.union([Schema1, Schema2])`                 |
| Validation + transformation               | zod + transform     | `Schema.transform(...)`                       |
| Business logic validation                 | zod + refine        | `Schema.refine((data) => ...)`                |
| 🚫 Never do this                          | Type assertions     | `return val as User`                          |

## Benefits

- **Type Safety**: Schemas as source of truth eliminate type/validation drift
- **Runtime Validation**: Comprehensive validation catches invalid data at runtime
- **Single Source of Truth**: One schema defines both TypeScript types and validation
- **Maintainability**: Schema changes automatically update types and validation
- **Documentation**: Schemas serve as living documentation of data contracts
- **Testing**: Easy to test validation logic with various input scenarios
- **Error Prevention**: Prevents runtime errors from invalid data assumptions
- **Performance**: Direct schema validation without additional lookup layers
