---
description:
globs:
alwaysApply: true
---
# TypeScript Patterns

Core TypeScript coding patterns and preferences.

## Rules

-   Prefer destructuring assignment over property access
-   Template literals over string concatenation
-   `async/await` over `.then()` chains for promises
-   Spread operator `[...array]` over `Array.from()` for array conversion
-   Always provide explicit types for function parameters and return types
-   Use type guards with single-line returns when simple
-   Prefer `Record<string, T>` over index signatures when appropriate

## Examples

### Destructuring Assignment

```typescript
// Preferred - destructuring
const { name, age, email } = user;
const { data, error } = response;

// Avoid - property access
const name = user.name; // Less concise
const age = user.age;
```

### Template Literals

```typescript
// Preferred - template literals
const message = `Hello ${name}, you are ${age} years old`;
const url = `${baseUrl}/api/users/${userId}`;

// Avoid - string concatenation
const message = "Hello " + name + ", you are " + age + " years old"; // BAD
```

### Async/Await

```typescript
// Preferred - async/await
const fetchUserData = async (userId: string): Promise<User> => {
    const response = await fetch(`/api/users/${userId}`);
    const data = await response.json();
    return data;
};

// Avoid - .then() chains
const fetchUserData = (userId: string): Promise<User> => {
    return fetch(`/api/users/${userId}`)
        .then((response) => response.json())
        .then((data) => data); // BAD - less readable
};
```

### Spread Operator

```typescript
// Preferred - spread operator
const newArray = [...existingArray, newItem];
const combined = [...array1, ...array2];

// Avoid - Array.from()
const newArray = Array.from(existingArray).concat([newItem]); // BAD
```

### Type Guards

```typescript
import { isString, isObject, isArray, isEmpty } from "lodash";

// ✅ GOOD - Use lodash type checkers for simple guards
const isValidString = (value: unknown): value is string => isString(value) && !isEmpty(value);

// ✅ GOOD - Combine lodash checks for complex type guards
const isValidUser = (data: unknown): data is User => {
    return (
        isObject(data) &&
        !isArray(data) &&
        "name" in data &&
        "email" in data &&
        isString((data as any).name) &&  // 'any' allowed in test type guards only
        isString((data as any).email)     // 'any' allowed in test type guards only
    );
};

// ❌ BAD - Manual type checking (use lodash instead)
const isString = (value: unknown): value is string => typeof value === "string";
const isValidUser = (data: unknown): data is User => {
    const isObject = typeof data === "object" && data !== null;
    const hasRequiredFields = "name" in data && "email" in data;
    return isObject && hasRequiredFields;
};
```
