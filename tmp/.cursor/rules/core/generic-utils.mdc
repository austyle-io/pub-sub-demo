---
description:
globs:
alwaysApply: true
---
# Type-Safe Generic Utils

Rules for creating and using type-safe generic utility functions for maximum reusability and type safety.

## Rules

-   Prefer generic utility functions over specific implementations
-   Always provide proper type parameters and constraints
-   Use type guards and runtime validation for better type safety
-   Create reusable utilities that work across different data types
-   Leverage TypeScript's type inference when possible

## Generic Utility Patterns

```typescript
// ✅ GOOD - Generic array utility with type safety
const groupBy = <T, K extends keyof T>(array: T[], key: K): Record<string, T[]> => {
    return array.reduce(
        (groups, item) => {
            const groupKey = String(item[key]);
            groups[groupKey] = groups[groupKey] || [];
            groups[groupKey].push(item);
            return groups;
        },
        {} as Record<string, T[]>,
    );
};

// Usage with full type safety
const users: User[] = [
    { id: "1", name: "John", role: "admin" },
    { id: "2", name: "Jane", role: "user" },
];

const usersByRole = groupBy(users, "role"); // Type: Record<string, User[]>

// ❌ BAD - Non-generic utility
const groupUsersByRole = (users: User[]) => {
    return users.reduce(
        (groups, user) => {
            groups[user.role] = groups[user.role] || [];
            groups[user.role].push(user);
            return groups;
        },
        {} as Record<string, User[]>,
    );
};
```

## Generic Validation Utilities

```typescript
// ✅ GOOD - Generic validation with type guards
const isValidObject = <T>(value: unknown, validator: (obj: any) => obj is T): value is T => {
    return typeof value === "object" && value !== null && validator(value);
};

const hasRequiredFields = <T extends Record<string, any>>(obj: unknown, fields: (keyof T)[]): obj is T => {
    if (typeof obj !== "object" || obj === null) return false;

    return fields.every((field) => field in obj);
};

// Usage
const isUser = (obj: any): obj is User => {
    return hasRequiredFields<User>(obj, ["id", "name", "email"]);
};

const validateApiResponse = <T>(data: unknown, validator: (obj: any) => obj is T): T | null => {
    return isValidObject(data, validator) ? data : null;
};

// ❌ BAD - Non-generic validation
const validateUser = (data: unknown): User | null => {
    if (typeof data !== "object" || data === null) return null;
    if (!("id" in data && "name" in data && "email" in data)) return null;
    return data as User;
};
```

## Generic State Management

```typescript
// ✅ GOOD - Generic state management utilities
const createAsyncState = <T, E = Error>() => {
    type AsyncState<T, E> = {
        data: T | null;
        loading: boolean;
        error: E | null;
    };

    const initialState: AsyncState<T, E> = {
        data: null,
        loading: false,
        error: null,
    };

    const createActions = () => ({
        setLoading: (loading: boolean): Partial<AsyncState<T, E>> => ({ loading }),
        setData: (data: T): Partial<AsyncState<T, E>> => ({ data, loading: false, error: null }),
        setError: (error: E): Partial<AsyncState<T, E>> => ({ error, loading: false }),
        reset: (): AsyncState<T, E> => initialState,
    });

    return { initialState, createActions };
};

// Usage with type safety
const { initialState: userState, createActions: userActions } = createAsyncState<User[], ApiError>();

// ❌ BAD - Specific state management
const createUserState = () => {
    const initialState = {
        users: null as User[] | null,
        loading: false,
        error: null as string | null,
    };

    return { initialState };
};
```

## Generic Array Utilities

```typescript
// ✅ GOOD - Generic array utilities with constraints
const sortBy = <T, K extends keyof T>(array: T[], key: K, direction: "asc" | "desc" = "asc"): T[] => {
    return [...array].sort((a, b) => {
        const aValue = a[key];
        const bValue = b[key];

        if (aValue < bValue) return direction === "asc" ? -1 : 1;
        if (aValue > bValue) return direction === "asc" ? 1 : -1;
        return 0;
    });
};

const findByProperty = <T, K extends keyof T>(array: T[], key: K, value: T[K]): T | undefined => {
    return array.find((item) => item[key] === value);
};

const filterByProperty = <T, K extends keyof T>(array: T[], key: K, predicate: (value: T[K]) => boolean): T[] => {
    return array.filter((item) => predicate(item[key]));
};

// Usage
const users: User[] = [
    { id: "1", name: "John", age: 30 },
    { id: "2", name: "Jane", age: 25 },
];

const sortedUsers = sortBy(users, "age", "desc"); // Fully typed
const foundUser = findByProperty(users, "id", "1"); // Type: User | undefined
const youngUsers = filterByProperty(users, "age", (age) => age < 30); // Type: User[]
```

## Generic API Utilities

```typescript
// ✅ GOOD - Generic API utilities
const createApiClient = <TConfig extends Record<string, any>>(config: TConfig) => {
    const request = async <TResponse>(endpoint: string, options?: RequestInit): Promise<TResponse> => {
        const response = await fetch(`${config.baseUrl}${endpoint}`, {
            ...config.defaultOptions,
            ...options,
        });

        if (!response.ok) {
            throw new Error(`API Error: ${response.status}`);
        }

        return response.json();
    };

    const get = <TResponse>(endpoint: string) => request<TResponse>(endpoint);

    const post = <TResponse, TBody = any>(endpoint: string, body: TBody) =>
        request<TResponse>(endpoint, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(body),
        });

    return { get, post, request };
};

// Usage with type safety
const apiClient = createApiClient({
    baseUrl: "https://api.example.com",
    defaultOptions: { headers: { Authorization: "Bearer token" } },
});

// Fully typed responses
const users = await apiClient.get<User[]>("/users");
const newUser = await apiClient.post<User, CreateUserRequest>("/users", userData);
```

## Generic Cache Utilities

```typescript
// ✅ GOOD - Generic cache with TTL
class TypedCache<T> {
    private cache = new Map<string, { data: T; timestamp: number; ttl: number }>();

    set(key: string, data: T, ttl = 300000): void {
        this.cache.set(key, {
            data,
            timestamp: Date.now(),
            ttl,
        });
    }

    get(key: string): T | null {
        const entry = this.cache.get(key);

        if (!entry) return null;

        if (Date.now() - entry.timestamp > entry.ttl) {
            this.cache.delete(key);
            return null;
        }

        return entry.data;
    }

    has(key: string): boolean {
        return this.get(key) !== null;
    }

    clear(): void {
        this.cache.clear();
    }
}

// Usage with full type safety
const userCache = new TypedCache<User>();
const statsCache = new TypedCache<DashboardStats>();

userCache.set("user-1", userData); // Only accepts User type
const cachedUser = userCache.get("user-1"); // Returns User | null
```

## Benefits

-   **Reusability**: Generic utilities work across different data types
-   **Type Safety**: Full TypeScript type checking and inference
-   **Maintainability**: Single implementation serves multiple use cases
-   **Performance**: Better tree-shaking and code optimization
-   **Developer Experience**: Better autocomplete and error detection
-   **Consistency**: Uniform behavior across different data types
