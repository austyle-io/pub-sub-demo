---
description:
globs:
alwaysApply: true
---
# Type System Preferences

TypeScript type system patterns and preferences.

## Rules

- **NEVER** use `interface` declarations - always use `type` instead
- **NEVER** use naming patterns like `IMyObject` or `MyObjectInterface`
- **Prefer named types over inline object types** for better reusability and clarity
- Generic utility functions whenever possible
- Always use `unknown`; never use `any` (except in test files for mocking)
- Prefer built-in utility types (`Partial<T>`) over custom types
- Use `satisfies` over duck typing; avoid duck typing and alert when it is used
- Runtime validation with Zod

## Examples

### Named Types Over Inline Types

```typescript
// ✅ GOOD - Named type for reusability and clarity
type Resource = {
    dispose: () => void;
};

type CacheEntry = {
    data: unknown;
    timestamp: number;
    ttl: number;
};

class ResourceManager {
    addResource(id: string, resource: Resource): void {
        // Implementation
    }

    addCacheEntry(key: string, entry: CacheEntry): void {
        // Implementation
    }
}

// ❌ BAD - Inline object types
class ResourceManager {
    addResource(id: string, resource: { dispose: () => void }): void {
        // BAD - inline type, not reusable
    }

    addCacheEntry(key: string, entry: { data: unknown; timestamp: number; ttl: number }): void {
        // BAD - complex inline type, hard to read
    }
}
```

### Type Over Interface

```typescript
// ✅ GOOD - Type usage
type UserConfig = {
    name: string;
};

type User = {
    id: string;
};

type UserService = {
    getUser(): User;
};

// ❌ BAD - Interface usage
interface UserConfig {
    name: string;
}

interface IUser {
    // BAD - I* prefix
    id: string;
}

interface UserServiceInterface {
    // BAD - *Interface suffix
    getUser(): User;
}
```

### Satisfies Over Assertions

```typescript
// Preferred - satisfies
const config = {
    apiUrl: "/api",
    timeout: 5000,
    retries: 3,
} satisfies ApiConfig;

// Avoid - type assertion
const config = {
    apiUrl: "/api",
    timeout: 5000,
    retries: 3,
} as ApiConfig; // BAD - no type checking
```

### Unknown Over Any

```typescript
// ✅ GOOD - unknown in production code
const processData = (data: unknown): ProcessedData => {
    if (typeof data === "object" && data !== null) {
        // Type narrowing required
        return processObject(data);
    }
    throw new Error("Invalid data type");
};

// ❌ BAD - any in production code
const processData = (data: any): ProcessedData => {
    // BAD - no type safety
    return processObject(data);
};

// ✅ ACCEPTABLE - any in test files only
// test/mocks/handlers.ts
const mockResponse = {
    data: { id: 1, name: "Test" } as any,  // OK in test files for mocking
    status: 200
};
```

### Built-in Utility Types

```typescript
// Preferred - built-in utilities
type PartialUser = Partial<User>;
type UserEmail = Pick<User, "email">;
type UserWithoutId = Omit<User, "id">;

// Avoid - custom types for common patterns
type PartialUser = {
    // BAD - reinventing the wheel
    name?: string;
    age?: number;
    email?: string;
};
```

### Runtime Validation

```typescript
// Preferred - Zod validation
const UserSchema = z.object({
    name: z.string(),
    age: z.number(),
    email: z.string().email(),
});

type User = z.infer<typeof UserSchema>;

const isUser = (data: unknown): data is User => UserSchema.safeParse(data).success;
```
