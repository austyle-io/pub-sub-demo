---
description:
globs:
alwaysApply: true
---
# Explicit vs Implicit Patterns

Rules for choosing explicit patterns over implicit ones for better code clarity and intention.

## Rules

- **ALWAYS use lodash utility functions** instead of manual implementations
- **Always use `isNil()` for all null/undefined checks** instead of implicit `!value`
- **Always use `isEmpty()` for empty array/object checks** instead of `array.length === 0`
- **Always use lodash type checkers** (`isString`, `isObject`, `isArray`, etc.) for type checking
- **Use `has()` for property existence checks** instead of `in` operator or manual checks
- **Use implicit negation (`!`) or double bang (`!!`)** for truthy evaluations only
- **Use optional chaining (`?.`) only when necessary**, not defensively everywhere
- **Prefer explicit equality** for boolean property checks in complex conditions

## Core Philosophy: Lodash-First Approach

**Use lodash as much as possible while maintaining type safety:**

1. **Handles edge cases**: null prototypes, Sets, Maps, TypedArrays, sparse arrays
2. **Consistent behavior**: Same API across different data types
3. **Better readability**: Intent is immediately clear
4. **Battle-tested**: Used by millions of developers, thoroughly tested
5. **Minimal overhead**: Tree-shaking keeps bundle impact under 2KB
6. **Type safety preserved**: Use lodash when it doesn't compromise TypeScript inference or type checking

## Examples

### Null/Undefined Checks

```typescript
import { isNil } from "lodash";

// ✅ EXPLICIT - Use isNil() for clarity
if (isNil(state.map)) return;
if (isNil(mapRef.current)) return;
if (isNil(entry)) return null;

// ❌ IMPLICIT - Ambiguous intention
if (!state.map) return; // BAD - unclear if checking null, undefined, or falsy
if (!mapRef.current) return; // BAD - could be checking existence or value
```

### Empty Array/Object Checks

```typescript
import { isEmpty } from "lodash";

// ✅ EXPLICIT - Use isEmpty() for clarity and edge case handling
if (isEmpty(changes)) return;
if (!isEmpty(state.errors)) {
    // Handle errors
}
if (isEmpty(userList)) {
    showEmptyState();
}

// ❌ IMPLICIT - Less reliable and unclear
if (changes.length === 0) return; // BAD - only works for arrays
if (state.errors.length > 0) {
    // BAD - assumes array, not object, doesn't handle Sets/Maps
    // Handle errors
}
if (Object.keys(userList).length === 0) {
    // BAD - verbose and doesn't handle all cases
    showEmptyState();
}
```

### Type Checking

```typescript
import { isString, isNumber, isArray, isObject, isFunction, isBoolean, has } from "lodash";

// ✅ EXPLICIT - Use lodash type checkers
const processValue = (value: unknown) => {
    if (isString(value)) return value.trim();
    if (isNumber(value)) return value.toString();
    if (isArray(value)) return value.join(",");
    if (isObject(value) && has(value, "toString")) return value.toString();
};

const validateInput = (input: unknown) => {
    return (
        isObject(input) &&
        has(input, "name") &&
        isString((input as any).name) &&
        has(input, "age") &&
        isNumber((input as any).age)
    );
};

// ❌ IMPLICIT - Manual type checking (error-prone)
const processValue = (value: unknown) => {
    if (typeof value === "string") return value.trim(); // BAD - use isString()
    if (typeof value === "number") return value.toString(); // BAD - use isNumber()
    if (Array.isArray(value)) return value.join(","); // BAD - use isArray()
};
```

### Property Existence Checks

```typescript
import { has, get } from "lodash";

// ✅ EXPLICIT - Use has() for property checks
if (has(config, "apiUrl")) {
    const url = get(config, "apiUrl");
    // Use url
}

if (has(user, "preferences.theme")) {
    const theme = get(user, "preferences.theme");
    // Use theme
}

// ❌ IMPLICIT - Manual property checks
if ("apiUrl" in config && config.apiUrl !== undefined) {
    // BAD - verbose
    const url = config.apiUrl;
}
```

### Object Manipulation

```typescript
import { cloneDeep, merge, pick, omit } from "lodash";

// ✅ EXPLICIT - Use lodash for object operations
const updateUser = (user: User, updates: Partial<User>) => {
    return merge(cloneDeep(user), updates);
};

const safeUserData = (user: User) => {
    return omit(user, ["password", "ssn", "creditCard"]);
};

const userSummary = (user: User) => {
    return pick(user, ["id", "name", "email", "role"]);
};

// ❌ IMPLICIT - Manual object manipulation (error-prone)
const updateUser = (user: User, updates: Partial<User>) => {
    return { ...user, ...updates }; // BAD - shallow copy, doesn't handle deep merging
};
```

### Collection Operations

```typescript
import { groupBy, sortBy, uniq, compact, findIndex } from "lodash";

// ✅ EXPLICIT - Use lodash for collections
const organizeUsers = (users: User[]) => {
    const uniqueUsers = uniq(users); // Handles object equality properly
    const activeUsers = compact(uniqueUsers.map((u) => (u.isActive ? u : null)));
    const usersByRole = groupBy(activeUsers, "role");
    const sortedByName = sortBy(activeUsers, "name");

    return { usersByRole, sortedByName };
};

// ❌ IMPLICIT - Manual collection operations
const organizeUsers = (users: User[]) => {
    // BAD - manual unique (doesn't handle object equality)
    const uniqueUsers = users.filter((user, index, arr) => arr.findIndex((u) => u.id === user.id) === index);

    // BAD - manual compact
    const activeUsers = uniqueUsers.filter((u) => u.isActive);
};
```

### Truthy Evaluations

```typescript
// ✅ IMPLICIT - Use ! or !! for truthy checks (this is appropriate)
const isActive = !!user.preferences.notifications;
const hasPermissions = !isEmpty(user.roles) && !!user.isActive;

// Boolean properties in filters - implicit negation is preferred
const activeUsers = users.filter((user) => !user.deleted && !user.suspended);

// ✅ EXPLICIT - For complex boolean logic, be explicit when needed
const isEligible = user.verified === true && user.suspended === false && user.role !== "guest";
```

### Optional Chaining - Only When Necessary

```typescript
// ✅ GOOD - Use optional chaining when necessary
const userName = user?.profile?.name; // Necessary - deeply nested
const callback = options?.onComplete?.(); // Necessary - optional callback
source?.setData(data); // Necessary - source might not exist

// ✅ GOOD - Use lodash get() for complex paths
const deepValue = get(config, "api.endpoints.users.url");

// ✅ GOOD - Direct access when guaranteed
map.getCenter().lng; // Good - map is guaranteed to exist
state.config.layers; // Good - config is always defined

// ❌ OVERUSE - Defensive optional chaining
const center = map?.getCenter()?.lng; // BAD - if map exists, getCenter() always returns
const layers = state?.config?.layers; // BAD - state and config are always defined
```

## Why This Matters

### Clarity of Intention

- `isNil(value)` clearly indicates checking for null/undefined
- `isEmpty(array)` works for arrays, objects, strings, Sets, Maps, and other collections
- `has(obj, "prop")` is more precise than `"prop" in obj` for property existence
- `!value` could mean many things - avoid ambiguity

### Consistency

- Lodash utilities provide consistent behavior across different types
- Explicit patterns make code self-documenting
- Reduces cognitive load when reading code

### Error Prevention

- `isEmpty()` handles edge cases that `length === 0` doesn't (Sets, Maps, sparse arrays)
- `isNil()` is more precise than `!value` for null checks
- `has()` properly handles null prototypes and inherited properties
- Type checkers prevent runtime errors and improve TypeScript inference
