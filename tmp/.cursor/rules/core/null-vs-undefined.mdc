---
description:
globs:
alwaysApply: true
---
# Null vs Undefined Pattern

Use `undefined` for optionality; use `null` for explicit empty values and intentional clearing.

## Rules

- Use `undefined` for optional properties, variables not yet set, or to signal absence
- Use `null` only when you need to explicitly represent "no value" or to intentionally clear a value
- Prefer `?` optional properties over explicit `| undefined` unions
- Use `isNil()` from lodash for checking both null and undefined
- Use `null` in serializable objects only if consumers require the field to be present with empty value
- Return `null` (not undefined) from React components to render nothing

## TypeScript Type Patterns

```typescript
import { isNil } from "lodash";

// ✅ GOOD - Optional properties with ?
type User = {
    id: string;
    name: string;
    email: string;
    middleName?: string; // Optional - may be undefined or omitted
    avatar?: string;
};

// ✅ GOOD - Null for explicit "no value" state
type UserPreferences = {
    theme: string;
    notifications: boolean;
    customAvatar: string | null; // null = intentionally no custom avatar
};

// ✅ GOOD - State that starts empty
const [selectedUser, setSelectedUser] = useState<User | null>(null);
const [searchQuery, setSearchQuery] = useState<string>("");

// ❌ BAD - Redundant undefined union
type BadUser = {
    middleName?: string | undefined; // Redundant - ? already allows undefined
};

// ❌ BAD - Triple union unless required by external API
type ConfusingState = {
    value: string | null | undefined; // Avoid unless API requires both
};
```

## Checking for Null/Undefined

```typescript
import { isNil, isUndefined, isNull } from "lodash";

// ✅ GOOD - Use isNil() for both null and undefined checks
const processUser = (user: User | null | undefined) => {
    if (isNil(user)) {
        return "No user provided";
    }
    return `Hello, ${user.name}`;
};

// ✅ GOOD - Specific checks when you need to distinguish
const handleValue = (value: string | null | undefined) => {
    if (isUndefined(value)) {
        return "Value not provided";
    }
    if (isNull(value)) {
        return "Value explicitly cleared";
    }
    return value;
};

// ❌ BAD - Manual null/undefined checks
const processUser = (user: User | null | undefined) => {
    if (user === null || user === undefined) {
        // Use isNil() instead
        return "No user provided";
    }
    return `Hello, ${user.name}`;
};

// ❌ BAD - Implicit truthiness check when you mean null/undefined
const processUser = (user: User | null | undefined) => {
    if (!user) {
        // Ambiguous - could mean falsy values too
        return "No user provided";
    }
    return `Hello, ${user.name}`;
};
```

## React Component Patterns

```typescript
import { ReactNode } from "react";

// ✅ GOOD - Optional props with defaults
type ModalProps = {
    title: string;
    children: ReactNode;
    footer?: ReactNode; // Optional - may be undefined
    onClose?: () => void;
};

export const Modal = ({ title, children, footer, onClose }: ModalProps) => {
    return (
        <div className="modal">
            <header>
                <h2>{title}</h2>
                {onClose && <button onClick={onClose}>×</button>}
            </header>
            <main>{children}</main>
            {footer && <footer>{footer}</footer>}
        </div>
    );
};

// ✅ GOOD - Null to explicitly hide/remove elements
type CardProps = {
    title: string;
    subtitle?: string;
    actions?: ReactNode | null; // null = intentionally no actions
};

export const Card = ({ title, subtitle, actions }: CardProps) => {
    return (
        <div className="card">
            <h3>{title}</h3>
            {subtitle && <p>{subtitle}</p>}
            {actions !== null && (
                <div className="actions">
                    {actions || <DefaultActions />}
                </div>
            )}
        </div>
    );
};

// ✅ GOOD - Conditional rendering returns null
const ConditionalComponent = ({ show, children }: { show: boolean; children: ReactNode }) => {
    if (!show) return null; // Return null to render nothing

    return <div>{children}</div>;
};

// ❌ BAD - Returning undefined from component
const BadComponent = ({ show }: { show: boolean }) => {
    if (!show) return undefined; // Should return null
    return <div>Content</div>;
};
```

## API and Serialization Patterns

```typescript
// ✅ GOOD - API request types
type CreateUserRequest = {
    name: string;
    email: string;
    middleName?: string; // Optional - omitted if not provided
    avatar?: string;
};

type UpdateUserRequest = {
    name?: string;
    email?: string;
    avatar?: string | null; // null = explicitly remove avatar
};

// ✅ GOOD - API response types matching backend
type UserResponse = {
    id: string;
    name: string;
    email: string;
    middleName: string | null; // Backend returns null for no middle name
    createdAt: string;
};

// ✅ GOOD - Serialization handling
const serializeUserPreferences = (prefs: UserPreferences) => {
    return {
        theme: prefs.theme,
        notifications: prefs.notifications,
        // Explicit null preserved in JSON
        customAvatar: prefs.customAvatar, // null stays null
        // Undefined properties omitted from JSON
        ...(prefs.advancedSettings && { advancedSettings: prefs.advancedSettings }),
    };
};
```

## State Management Patterns

```typescript
// ✅ GOOD - Initial state patterns
type AppState = {
    currentUser: User | null; // null = no user logged in
    selectedProject: Project | null; // null = no project selected
    searchResults: SearchResult[]; // Empty array, not null/undefined
};

const initialState: AppState = {
    currentUser: null, // Explicitly no user
    selectedProject: null, // Explicitly no selection
    searchResults: [], // Empty array
};

// ✅ GOOD - State updates
const userReducer = (state: AppState, action: Action): AppState => {
    switch (action.type) {
        case "LOGIN":
            return {
                ...state,
                currentUser: action.user, // Set user
            };
        case "LOGOUT":
            return {
                ...state,
                currentUser: null, // Explicitly clear user
            };
        case "SELECT_PROJECT":
            return {
                ...state,
                selectedProject: action.project,
            };
        case "CLEAR_SELECTION":
            return {
                ...state,
                selectedProject: null, // Explicitly clear selection
            };
        default:
            return state;
    }
};
```

## Form Handling Patterns

```typescript
// ✅ GOOD - Form state with appropriate defaults
type FormState = {
    name: string; // Always has a value, even if empty string
    email: string;
    phone: string; // Empty string for optional field
    newsletter: boolean; // Boolean, not null/undefined
};

const initialFormState: FormState = {
    name: "",
    email: "",
    phone: "",
    newsletter: false,
};

// ✅ GOOD - Form validation
const validateForm = (form: FormState): Record<string, string> => {
    const errors: Record<string, string> = {};

    if (!form.name.trim()) {
        errors.name = "Name is required";
    }

    if (!form.email.trim()) {
        errors.email = "Email is required";
    }

    return errors;
};

// ❌ BAD - Using null/undefined for form values
type BadFormState = {
    name: string | null; // Forms should use empty string
    email: string | undefined; // Forms should use empty string
};
```

## Utility Function Patterns

```typescript
import { isNil, isEmpty } from "lodash";

// ✅ GOOD - Utility functions handling null/undefined appropriately
const formatUserName = (user: User | null | undefined): string => {
    if (isNil(user)) {
        return "Unknown User";
    }

    const { name, middleName } = user;
    return middleName ? `${name} ${middleName}` : name;
};

const getUserInitials = (user: User | null | undefined): string => {
    if (isNil(user) || isEmpty(user.name)) {
        return "??";
    }

    return user.name
        .split(" ")
        .map((part) => part.charAt(0).toUpperCase())
        .join("")
        .slice(0, 2);
};

// ✅ GOOD - Optional chaining with null coalescing
const getUserEmail = (user: User | null | undefined): string => {
    return user?.email ?? "no-email@example.com";
};
```

## Benefits

- **Clarity**: Clear distinction between "not provided" (undefined) and "intentionally empty" (null)
- **API Consistency**: Matches common API patterns and JSON serialization behavior
- **Type Safety**: Explicit optional properties prevent undefined-related runtime errors
- **React Integration**: Follows React conventions for conditional rendering and prop patterns
- **Serialization**: Predictable behavior when converting to/from JSON
- **Debugging**: Easier to identify intended vs accidental missing values
