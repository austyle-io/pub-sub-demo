---
description:
globs:
alwaysApply: true
---
# Duck Typing Prevention

Ban duck typing except for rare, justified cases. Prefer explicit type checking with the `satisfies` operator.

## Rules

- **Avoid duck typing** - Don't assign anonymous objects to variables or parameters based solely on structural compatibility
- **Use `satisfies` operator** - Explicitly check object conformity to interfaces or types
- **Ban type assertions** - Never use `as TypeName` assertions, which bypass type safety
- **Document exceptions** - Only use direct duck typing in extreme, justified circumstances with clear documentation
- **Preserve literal types** - `satisfies` maintains exact literal types while ensuring compatibility

## Required Pattern

```typescript
// ✅ PREFERRED - Use satisfies operator
const user = {
    name: "Tyler",
    age: 36,
    email: "tyler@example.com",
} satisfies User;

const config = {
    apiUrl: "/api/v1",
    timeout: 5000,
    retries: 3,
} satisfies ApiConfig;

// ✅ ACCEPTABLE - Explicit type annotation with satisfies
const themeConfig: ThemeConfig = {
    primaryColor: "#007acc",
    secondaryColor: "#6c757d",
    fontSize: 16,
} satisfies ThemeConfig;
```

## Forbidden Patterns

```typescript
// ❌ BANNED - Duck typing assignment
const user: User = {
    name: "Tyler",
    age: 36,
    email: "tyler@example.com",
}; // BAD - duck typing, loses literal types

// ❌ BANNED - Type assertion
const user = {
    name: "Tyler",
    age: 36,
    email: "tyler@example.com",
} as User; // BAD - bypasses type safety

// ❌ BANNED - Implicit duck typing
const processUser = (userData: User) => {
    // ...
};

// Calling with anonymous object (duck typing)
processUser({
    name: "Tyler",
    age: 36,
    email: "tyler@example.com",
}); // BAD - implicit duck typing
```

## Why Use `satisfies`?

### 1. Preserves Literal Types

```typescript
const theme = {
    colors: {
        primary: "#007acc", // Literal type: "#007acc"
        secondary: "#6c757d", // Literal type: "#6c757d"
    },
    sizes: {
        small: 12, // Literal type: 12
        medium: 16, // Literal type: 16
        large: 20, // Literal type: 20
    },
} satisfies ThemeConfig;

// You can still access exact literal types
type PrimaryColor = typeof theme.colors.primary; // "#007acc"
type SmallSize = typeof theme.sizes.small; // 12

// ❌ With duck typing, you lose literal types
const badTheme: ThemeConfig = {
    colors: {
        primary: "#007acc", // Type: string (lost precision)
        secondary: "#6c757d", // Type: string (lost precision)
    },
    sizes: {
        small: 12, // Type: number (lost precision)
        medium: 16, // Type: number (lost precision)
        large: 20, // Type: number (lost precision)
    },
};
```

### 2. Type Safety with Flexibility

```typescript
type DatabaseConfig = {
    host: string;
    port: number;
    database: string;
    ssl?: boolean;
};

// ✅ GOOD - satisfies ensures type safety
const dbConfig = {
    host: "localhost",
    port: 5432,
    database: "myapp",
    ssl: true,
    // Extra properties are allowed and preserved
    connectionTimeout: 30000,
    maxConnections: 100,
} satisfies DatabaseConfig;

// You can access both required and extra properties
const timeout = dbConfig.connectionTimeout; // Available!
const host = dbConfig.host; // Type-safe access
```

### 3. Better Error Messages

```typescript
// ✅ GOOD - Clear error at the property level
const config = {
    apiUrl: "/api/v1",
    timeout: "5000", // ❌ Error: Type 'string' is not assignable to type 'number'
    retries: 3,
} satisfies ApiConfig;

// ❌ BAD - Error at assignment level, less specific
const config: ApiConfig = {
    apiUrl: "/api/v1",
    timeout: "5000", // Error is less clear
    retries: 3,
};
```

## When Duck Typing is Acceptable

### 1. Test Data

```typescript
// ✅ ACCEPTABLE - Test mock data with documentation
// @ts-expect-error - Test data uses simplified User structure for readability
const mockUser: User = {
    name: "Test User",
    email: "test@example.com",
    // Omitting other required fields for test simplicity
};
```

### 2. External Library Compatibility

```typescript
// ✅ ACCEPTABLE - External library requires exact interface match
// @ts-expect-error - Third-party library expects exact interface, satisfies not compatible
const thirdPartyOptions: ExternalLibraryOptions = rawOptions as ExternalLibraryOptions;
```

### 3. Migration Scenarios

```typescript
// ✅ ACCEPTABLE - During migration from legacy types
// @ts-expect-error - Temporary during migration to new User type in v2.0
const legacyUser: User = oldUserData as User;
```

## Benefits

- **Type Precision**: Maintains exact literal types while ensuring compatibility
- **Type Safety**: Full TypeScript checking without type assertion bypasses
- **Flexibility**: Allows extra properties that aren't in the type definition
- **Better DX**: Clearer error messages and better autocomplete
- **Refactoring**: Safer refactoring with preserved type information
- **Documentation**: Code intent is explicitly clear
