---
description:
globs:
alwaysApply: true
---
# React Component Patterns

Rules for React component structure, props, and organization.

## Rules

-   Use arrow function components, not function declarations
-   Props should be explicitly typed with dedicated type definitions
-   Prefer composition over inheritance
-   Use meaningful prop names and provide good defaults
-   Never use `React.FC` type annotation for components
-   Declare props as a type and export type if needed outside component

## Component Size Guidelines

### When to Refactor Components

**File Size Targets**: Keep component files between 50-150 lines

**Refactoring Strategies**:
1. **Extract Custom Hooks**: Move complex logic to custom hooks
2. **Break Out JSX**: Extract repeated or complex JSX into sub-components
3. **Apply SOLID Principles**: Single responsibility per component
4. **Follow DRY**: Don't repeat yourself - extract common patterns

### Example Refactoring

```typescript
// ❌ BAD - Component doing too much (200+ lines)
export const UserDashboard = ({ userId }: Props) => {
  // Too much state management
  const [user, setUser] = useState();
  const [posts, setPosts] = useState();
  const [comments, setComments] = useState();
  const [loading, setLoading] = useState();

  // Complex data fetching logic
  useEffect(() => {
    // 50 lines of fetching logic
  }, []);

  // Complex event handlers
  const handlePostCreate = () => {
    // 30 lines of logic
  };

  // Complex render with multiple sections
  return (
    <div>
      {/* 100+ lines of JSX */}
    </div>
  );
};

// ✅ GOOD - Refactored using hooks and sub-components
// hooks/useUserData.ts
const useUserData = (userId: string) => {
  const [user, setUser] = useState();
  const [loading, setLoading] = useState();
  // Encapsulated fetching logic
  return { user, loading };
};

// components/UserPosts.tsx
const UserPosts = ({ posts, onPostCreate }: UserPostsProps) => {
  // Single responsibility: display posts
  return <div>{/* Posts JSX */}</div>;
};

// UserDashboard.tsx (now ~50 lines)
export const UserDashboard = ({ userId }: Props) => {
  const { user, loading } = useUserData(userId);
  const { posts, createPost } = useUserPosts(userId);

  if (loading) return <LoadingSpinner />;

  return (
    <div>
      <UserHeader user={user} />
      <UserPosts posts={posts} onPostCreate={createPost} />
      <UserComments userId={userId} />
    </div>
  );
};
```

## Component Structure

```typescript
/**
 * @fileoverview Component Description
 */

// config/ui-constants.ts
export const BUTTON_VARIANT = {
  PRIMARY: 'primary',
  SECONDARY: 'secondary',
} as const;

export type ButtonVariant = (typeof BUTTON_VARIANT)[keyof typeof BUTTON_VARIANT];

// Component definition
type ButtonProps = {
  title: string;
  onClick?: () => void;
  variant?: ButtonVariant;
  disabled?: boolean;
};

export const Button = ({
  title,
  onClick,
  variant = BUTTON_VARIANT.PRIMARY,
  disabled = false
}: ButtonProps) => {
  const handleClick = () => {
    onClick?.();
  };

  return (
    <button
      onClick={handleClick}
      disabled={disabled}
      className={`btn btn-${variant}`}
    >
      {title}
    </button>
  );
};

// Export props type if needed elsewhere
export type { ButtonProps };
```

## Anti-Patterns

```typescript
// ❌ BAD - React.FC annotation
const Button: React.FC<ButtonProps> = ({ title, onClick }) => {
  return <button onClick={onClick}>{title}</button>;
};

// ❌ BAD - Function declaration
function Button({ title, onClick }: ButtonProps) {
  return <button onClick={onClick}>{title}</button>;
}

// ❌ BAD - Inline props type
const Button = ({ title, onClick }: { title: string; onClick?: () => void }) => {
  return <button onClick={onClick}>{title}</button>;
};
```

## Event Handler Naming

```typescript
import { ChangeEvent } from 'react';

type ComponentProps = {
  // Props use 'on' prefix
  onClick?: () => void;
  onSubmit?: (data: FormData) => void;
  onChange?: (value: string) => void;
};

export const Component = ({ onClick, onSubmit, onChange }: ComponentProps) => {
  // Internal handlers use 'handle' prefix
  const handleClick = () => {
    onClick?.();
  };

  const handleSubmit = (data: FormData) => {
    onSubmit?.(data);
  };

  const handleChange = (e: ChangeEvent<HTMLInputElement>) => {
    onChange?.(e.target.value);
  };

  return (
    <form onSubmit={handleSubmit}>
      <input onChange={handleChange} />
      <button onClick={handleClick}>Submit</button>
    </form>
  );
};
```

## Composition Over Inheritance

```typescript
import { ReactNode } from 'react';

// Preferred - composition
type BaseButtonProps = {
  children: ReactNode;
  onClick?: () => void;
};

const BaseButton = ({ children, onClick }: BaseButtonProps) => (
  <button onClick={onClick}>{children}</button>
);

type PrimaryButtonProps = {
  onClick?: () => void;
};

const PrimaryButton = ({ onClick }: PrimaryButtonProps) => (
  <BaseButton onClick={onClick}>
    <span className="primary-icon" />
    Primary Action
  </BaseButton>
);
```
