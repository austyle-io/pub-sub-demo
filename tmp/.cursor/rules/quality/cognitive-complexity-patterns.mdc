---
description:
globs:
alwaysApply: true
---

# Cognitive Complexity Reduction Patterns

Rules for reducing cognitive complexity in methods to stay under SonarQube thresholds (typically 15).

## Rules

- **Extract complex methods** into smaller, focused functions
- **Use early returns** instead of deeply nested conditions
- **Replace complex lookup objects** with switch statements + extracted handlers
- **Separate validation, processing, and error handling** into different methods
- **Limit method responsibility** to a single, clear purpose

## Method Extraction Patterns

### Complex Conditional Logic

```typescript
// ❌ BAD - High cognitive complexity with nested conditions
const processEvent = (payload: EventPayload) => {
    if (payload.type === "user") {
        if (payload.action === "create") {
            if (payload.data && payload.data.email) {
                // Complex validation logic
                // More nested conditions
                // Error handling
            }
        }
    }
};

// ✅ GOOD - Extracted into focused methods with lookup pattern
const processEvent = (payload: EventPayload) => {
    if (!isValidPayload(payload)) return;

    return getEventTypeHandler(payload.type)(payload);
};

const EVENT_TYPE_HANDLERS: Record<EventType, (payload: EventPayload) => void> = {
    [EVENT_TYPE.USER]: handleUserEvent,
    [EVENT_TYPE.SYSTEM]: handleSystemEvent,
} as const;

const getEventTypeHandler = (type: EventType) => {
    return EVENT_TYPE_HANDLERS[type] ?? handleUnknownEvent;
};

const handleUserEvent = (payload: EventPayload) => {
    return getUserActionHandler(payload.action)(payload);
};

const USER_ACTION_HANDLERS: Record<UserAction, (payload: EventPayload) => void> = {
    [USER_ACTION.CREATE]: createUser,
    [USER_ACTION.UPDATE]: updateUser,
} as const;

const getUserActionHandler = (action: UserAction) => {
    return USER_ACTION_HANDLERS[action] ?? logUnknownAction;
};

const createUser = (payload: EventPayload) => {
    if (!validateUserData(payload.data)) return;

    try {
        return processUserCreation(payload.data);
    } catch (error) {
        handleUserCreationError(error, payload);
    }
};
```

### Replace Complex Lookup Objects

```typescript
// ❌ BAD - Complex inline handlers
const applyChanges = (changes: Change[]) => {
    const handlers = {
        [CHANGE_TYPE.ADD]: (change) => {
            if (change.source && !map.getSource(change.source.id)) {
                const spec = toSourceSpec(change.source);
                if (spec) {
                    map.addSource(change.source.id, spec);
                } else {
                    logError("Invalid source", change);
                    return;
                }
            }
        },
        // More complex inline handlers...
    };

    for (const change of changes) {
        const handler = handlers[change.type];
        if (handler) {
            handler(change);
        }
    }
};

// ✅ GOOD - Lookup pattern with extracted handlers
const applyChanges = (changes: Change[]) => {
    for (const change of changes) {
        applyChange(change);
    }
};

const CHANGE_TYPE_HANDLERS: Record<ChangeType, (change: Change) => void> = {
    [CHANGE_TYPE.ADD]: handleAddChange,
    [CHANGE_TYPE.UPDATE]: handleUpdateChange,
    [CHANGE_TYPE.REMOVE]: handleRemoveChange,
} as const;

const applyChange = (change: Change) => {
    const handler = CHANGE_TYPE_HANDLERS[change.type];
    return handler ? handler(change) : logUnknownChange(change);
};

const handleAddChange = (change: Change) => {
    if (!validateAddChange(change)) return;

    const spec = createSourceSpec(change);
    addSourceToMap(change.source.id, spec);
};
```

### Early Returns Pattern

```typescript
// ❌ BAD - Deeply nested conditions
const processUser = (user: User) => {
    if (user) {
        if (user.isActive) {
            if (user.email) {
                if (isValidEmail(user.email)) {
                    // Process user
                    return processActiveUser(user);
                } else {
                    logError("Invalid email");
                }
            } else {
                logError("Missing email");
            }
        } else {
            logError("User inactive");
        }
    } else {
        logError("No user provided");
    }
};

// ✅ GOOD - Early returns
const processUser = (user: User) => {
    if (!user) {
        logError("No user provided");
        return;
    }

    if (!user.isActive) {
        logError("User inactive");
        return;
    }

    if (!user.email) {
        logError("Missing email");
        return;
    }

    if (!isValidEmail(user.email)) {
        logError("Invalid email");
        return;
    }

    return processActiveUser(user);
};
```

## Cleanup and Resource Management

### Extract Cleanup Methods

```typescript
// ❌ BAD - Mixed cleanup logic
const cleanup = () => {
    // Dispose resources with nested try-catch
    for (const resource of resources) {
        try {
            resource.dispose();
        } catch (e) {
            logError("Resource disposal failed", e);
        }
    }

    // Clear intervals
    for (const interval of intervals) {
        clearInterval(interval);
    }

    // Remove listeners with nested try-catch
    for (const listener of listeners) {
        try {
            listener.cleanup();
        } catch (e) {
            logError("Listener cleanup failed", e);
        }
    }
};

// ✅ GOOD - Separated cleanup responsibilities
const cleanup = () => {
    disposeResources();
    clearIntervals();
    removeListeners();
};

const disposeResources = () => {
    for (const resource of resources) {
        safeDispose(resource, "resource disposal");
    }
    resources.clear();
};

const clearIntervals = () => {
    for (const interval of intervals) {
        clearInterval(interval);
    }
    intervals.clear();
};

const removeListeners = () => {
    for (const listener of listeners) {
        safeDispose(listener, "listener cleanup");
    }
    listeners.clear();
};

const safeDispose = (disposable: Disposable, context: string) => {
    try {
        disposable.dispose();
    } catch (error) {
        logCleanupError(error, context);
    }
};
```

## Benefits

- **Reduced Complexity**: Each method has a single, clear purpose
- **Better Testing**: Smaller methods are easier to test in isolation
- **Improved Readability**: Code flow is easier to follow
- **Easier Debugging**: Problems can be isolated to specific methods
- **SonarQube Compliance**: Stays under cognitive complexity thresholds
- **Maintainability**: Changes are localized to specific responsibilities

## Metrics

- **Target**: Keep methods under 15 cognitive complexity points
- **Method Length**: Aim for 20-50 lines per method
- **Single Responsibility**: Each method should do one thing well
- **Nesting Levels**: Avoid more than 3 levels of nesting
