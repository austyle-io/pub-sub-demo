---
description:
globs:
alwaysApply: true
---
# Error Handling

Rules for error handling patterns and React error boundaries with proper TypeScript typing.

## Rules

-   Always use typed errors with proper error boundaries
-   Use `react-error-boundary` library for React error boundaries
-   Create reusable error boundary wrappers with proper prop forwarding
-   Always log complete error details to console for debugging
-   Use type intersection for combining prop types
-   Provide meaningful error messages with context
-   Include recovery suggestions when possible
-   Use const objects for error types/codes

## React Error Boundary Pattern

```typescript
"use client";

import { ReactNode } from "react";
import { ErrorBoundary as ReactErrorBoundary, FallbackProps } from "react-error-boundary";
import { Button } from "@/components";
import { cn } from "@/utils/classnames";
import { useComponentLogger } from "@/lib/hooks/useComponentLogger";

type ResetErrorBoundaryProps = {
    className?: string;
    onReset?: () => void;
};

type CustomErrorBoundaryProps = ResetErrorBoundaryProps & {
    children: ReactNode;
};

const ResetErrorBoundary = ({
    error,
    resetErrorBoundary,
    onReset,
    ...props
}: FallbackProps & ResetErrorBoundaryProps) => {
    const { className } = props;
    const { name, message, cause, stack } = error as Error;
    const logger = useComponentLogger("ResetErrorBoundary");

    // Always log complete error details for debugging
    logger.error("Error Boundary triggered", { name, message, cause, stack });

    const handleClick = () => {
        resetErrorBoundary();
        onReset?.();
    };

    return (
        <div className={cn("h-full flex flex-1 flex-col justify-center items-center gap-4", className)}>
            <div className="flex flex-col items-center gap-4">
                <h1 className="text-2xl font-bold">{name}</h1>
                <p className="text-sm text-gray-500">{message}</p>
                {cause && (
                    <p className="text-sm text-gray-500">{JSON.stringify(cause, null, 2)}</p>
                )}
            </div>
            <Button onClick={handleClick}>Reset</Button>
        </div>
    );
};

export const CustomErrorBoundary = ({ children, ...props }: CustomErrorBoundaryProps) => {
    return (
        <ReactErrorBoundary
            fallbackRender={({ ...fallbackProps }) => {
                const resetErrorBoundaryProps = { ...fallbackProps, ...props };
                return <ResetErrorBoundary {...resetErrorBoundaryProps} />;
            }}
        >
            {children}
        </ReactErrorBoundary>
    );
};
```

## Typed Error Objects

```typescript
// Error type constants
export const ERROR_TYPE = {
    VALIDATION: "validation",
    NETWORK: "network",
    PERMISSION: "permission",
    UNKNOWN: "unknown",
} as const;

export type ErrorType = (typeof ERROR_TYPE)[keyof typeof ERROR_TYPE];

// Typed error structure
export type ApplicationError = {
    type: ErrorType;
    message: string;
    code?: string;
    context?: Record<string, unknown>;
    recoverable: boolean;
    timestamp: string;
};

// Error creation utility
export const createError = (
    type: ErrorType,
    message: string,
    options?: {
        code?: string;
        context?: Record<string, unknown>;
        recoverable?: boolean;
    },
): ApplicationError => ({
    type,
    message,
    code: options?.code,
    context: options?.context,
    recoverable: options?.recoverable ?? true,
    timestamp: new Date().toISOString(),
});
```

## Error Boundary Usage Pattern

```typescript
// Usage in components
const UserManagement = () => {
    return (
        <CustomErrorBoundary
            className="p-6 border rounded-lg"
            onReset={() => {
                // Custom reset logic
                console.log("Error boundary reset");
            }}
        >
            <UserList />
            <UserForm />
        </CustomErrorBoundary>
    );
};

// Multiple error boundaries for different sections
const Dashboard = () => {
    return (
        <div>
            <CustomErrorBoundary>
                <Navigation />
            </CustomErrorBoundary>

            <CustomErrorBoundary onReset={() => refreshUserData()}>
                <UserSection />
            </CustomErrorBoundary>

            <CustomErrorBoundary onReset={() => refreshAnalytics()}>
                <AnalyticsSection />
            </CustomErrorBoundary>
        </div>
    );
};
```

## Async Error Handling

```typescript
// Error handling with async/await
const fetchUserData = async (userId: string): Promise<User | ApplicationError> => {
    try {
        const response = await fetch(`/api/users/${userId}`);

        if (!response.ok) {
            return createError(ERROR_TYPE.NETWORK, `Failed to fetch user: ${response.status}`, {
                code: `HTTP_${response.status}`,
                context: { userId, url: response.url },
                recoverable: response.status < 500,
            });
        }

        const data = await response.json();

        if (!isValidUser(data)) {
            return createError(ERROR_TYPE.VALIDATION, "Invalid user data received", {
                code: "INVALID_USER_DATA",
                context: { userId, data },
                recoverable: false,
            });
        }

        return data;
    } catch (error) {
        return createError(ERROR_TYPE.UNKNOWN, `Unexpected error: ${error.message}`, {
            code: "UNEXPECTED_ERROR",
            context: { userId, originalError: error },
            recoverable: true,
        });
    }
};
```

## Error Recovery Patterns

```typescript
// Component with error recovery
const UserProfile = ({ userId }: { userId: string }) => {
  const [user, setUser] = useState<User | null>(null);
  const [error, setError] = useState<ApplicationError | null>(null);
  const [retryCount, setRetryCount] = useState(0);

  const loadUser = async () => {
    setError(null);
    const result = await fetchUserData(userId);

    if ('type' in result) {
      // It's an error
      setError(result);

      // Auto-retry for recoverable errors
      if (result.recoverable && retryCount < 3) {
        setTimeout(() => {
          setRetryCount(prev => prev + 1);
          loadUser();
        }, 1000 * Math.pow(2, retryCount)); // Exponential backoff
      }
    } else {
      // It's valid user data
      setUser(result);
      setRetryCount(0);
    }
  };

  const handleRetry = () => {
    setRetryCount(0);
    loadUser();
  };

  if (error) {
    return (
      <div className="error-display">
        <p>Error: {error.message}</p>
        {error.recoverable && (
          <button onClick={handleRetry}>Retry</button>
        )}
      </div>
    );
  }

  return user ? <UserDetails user={user} /> : <LoadingSpinner />;
};
```

## Benefits

-   **Type Safety**: Errors are typed and predictable using react-error-boundary
-   **Reusability**: Error boundaries can be reused across different components
-   **Debugging**: Complete error logging with structured information
-   **Recovery**: Clear indication of recoverable vs permanent errors
-   **User Experience**: Meaningful error messages and recovery options
-   **Prop Forwarding**: Proper TypeScript typing with intersection types
-   **Customization**: Flexible error boundary wrappers for different use cases
