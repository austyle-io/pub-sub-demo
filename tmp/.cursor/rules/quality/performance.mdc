---
description:
globs:
alwaysApply: true
---
# Performance Considerations

Rules for React performance optimization and best practices.

## Rules

-   Use memo for expensive components (named import)
-   Prefer const assertions for static data
-   Consider lazy loading for large components

## memo Usage

```typescript
import { memo, useMemo } from 'react';

// Use memo for expensive components
type ExpensiveComponentProps = {
  data: ComplexData[];
  onUpdate: (item: ComplexData) => void;
};

export const ExpensiveComponent = memo(({ data, onUpdate }: ExpensiveComponentProps) => {
  // Expensive rendering logic
  const processedData = useMemo(() =>
    data.map(item => expensiveProcessing(item))
  );

  return (
    <div>
      {processedData.map(item => (
        <ComplexItem key={item.id} item={item} onUpdate={onUpdate} />
      ))}
    </div>
  );
});

// Custom comparison for complex props
export const OptimizedComponent = memo(
  ({ user, settings }: { user: User; settings: Settings }) => {
    return <UserInterface user={user} settings={settings} />;
  },
  (prevProps, nextProps) => {
    // Custom comparison logic
    return prevProps.user.id === nextProps.user.id &&
           prevProps.settings.version === nextProps.settings.version;
  }
);
```

## Const Assertions for Static Data

```typescript
// Prefer const assertions for static data
export const NAVIGATION_ITEMS = [
  { id: 'home', label: 'Home', icon: 'home' },
  { id: 'profile', label: 'Profile', icon: 'user' },
  { id: 'settings', label: 'Settings', icon: 'cog' },
] as const;

export const API_ENDPOINTS = {
  USERS: '/api/users',
  POSTS: '/api/posts',
  COMMENTS: '/api/comments',
} as const;

// Avoid recreating objects on each render
const EMPTY_ARRAY: readonly never[] = [];
const EMPTY_OBJECT = {} as const;

const Component = ({ items = EMPTY_ARRAY }: { items?: Item[] }) => {
  // Use const assertions to prevent re-renders
  return (
    <div>
      {items.map(item => <ItemComponent key={item.id} item={item} />)}
    </div>
  );
};
```

## Lazy Loading

```typescript
// Lazy load heavy components
const HeavyComponent = lazy(() => import('./HeavyComponent'));
const ChartComponent = lazy(() => import('./ChartComponent'));

const Dashboard = () => {
  const [showChart, setShowChart] = useState(false);

  return (
    <div>
      <Header />

      {showChart && (
        <Suspense fallback={<ChartSkeleton />}>
          <ChartComponent />
        </Suspense>
      )}

      <Suspense fallback={<ComponentSkeleton />}>
        <HeavyComponent />
      </Suspense>
    </div>
  );
};
```

## Virtualization for Large Lists

```typescript
// Use virtualization for large data sets
import { FixedSizeList as List } from 'react-window';

type VirtualizedListProps = {
  items: Item[];
  itemHeight: number;
  height: number;
};

const VirtualizedList = ({ items, itemHeight, height }: VirtualizedListProps) => {
  const Row = ({ index, style }: { index: number; style: CSSProperties }) => (
    <div style={style}>
      <ItemComponent item={items[index]} />
    </div>
  );

  return (
    <List
      height={height}
      itemCount={items.length}
      itemSize={itemHeight}
      width="100%"
    >
      {Row}
    </List>
  );
};
```

## Code Splitting

```typescript
// Split code by routes
const HomePage = lazy(() => import('../pages/HomePage'));
const UserPage = lazy(() => import('../pages/UserPage'));
const AdminPage = lazy(() => import('../pages/AdminPage'));

const AppRouter = () => (
  <Router>
    <Suspense fallback={<PageSkeleton />}>
      <Routes>
        <Route path="/" element={<HomePage />} />
        <Route path="/user/:id" element={<UserPage />} />
        <Route path="/admin" element={<AdminPage />} />
      </Routes>
    </Suspense>
  </Router>
);

// Split by feature
const AdvancedFeatures = lazy(() => import('../features/AdvancedFeatures'));

const App = () => {
  const [showAdvanced, setShowAdvanced] = useState(false);

  return (
    <div>
      <BasicFeatures />

      {showAdvanced && (
        <Suspense fallback={<FeatureSkeleton />}>
          <AdvancedFeatures />
        </Suspense>
      )}
    </div>
  );
};
```

## Performance Anti-Patterns

```typescript
// ❌ BAD - Creating objects in render
const BadComponent = ({ items }: { items: Item[] }) => {
  return (
    <div>
      {items.map(item => (
        <ItemComponent
          key={item.id}
          item={item}
          style={{ margin: '8px' }} // ❌ New object every render
          onClick={() => handleClick(item)} // ❌ New function every render
        />
      ))}
    </div>
  );
};

// ✅ GOOD - Memoized values and callbacks
const GoodComponent = ({ items }: { items: Item[] }) => {
  const itemStyle = useMemo(() => ({ margin: '8px' }));

  const handleItemClick = useCallback((item: Item) => {
    handleClick(item);
  });

  return (
    <div>
      {items.map(item => (
        <ItemComponent
          key={item.id}
          item={item}
          style={itemStyle}
          onClick={() => handleItemClick(item)}
        />
      ))}
    </div>
  );
};
```
