---
description:
globs:
alwaysApply: true
---
# Component Extraction Rules

Rules for extracting components from large files and maintaining single responsibility.

## When to Extract

-   Component has more than 100 lines
-   Multiple sub-components in one file
-   Mixed concerns (UI + business logic)
-   Hard to test individual parts

## Extraction Process

### 1. Identify Sub-Components

```typescript
// Before - monolithic component
const UserDashboard = () => {
  const UserHeader = () => (
    <div>
      <h1>Welcome {user.name}</h1>
      <UserAvatar user={user} />
    </div>
  );

  const UserStats = () => (
    <div>
      <StatCard title="Posts" value={user.posts.length} />
      <StatCard title="Followers" value={user.followers.length} />
    </div>
  );

  const UserActivity = () => (
    <div>
      {user.activities.map(activity => (
        <ActivityItem key={activity.id} activity={activity} />
      ))}
    </div>
  );

  return (
    <div>
      <UserHeader />
      <UserStats />
      <UserActivity />
    </div>
  );
};
```

### 2. Extract to Separate Files

```typescript
// components/UserHeader.tsx
type UserHeaderProps = {
  user: User;
};

export const UserHeader = ({ user }: UserHeaderProps) => (
  <div className="user-header">
    <h1>Welcome {user.name}</h1>
    <UserAvatar user={user} />
  </div>
);

// components/UserStats.tsx
type UserStatsProps = {
  user: User;
};

export const UserStats = ({ user }: UserStatsProps) => (
  <div className="user-stats">
    <StatCard title="Posts" value={user.posts.length} />
    <StatCard title="Followers" value={user.followers.length} />
  </div>
);

// components/UserActivity.tsx
type UserActivityProps = {
  activities: Activity[];
};

export const UserActivity = ({ activities }: UserActivityProps) => (
  <div className="user-activity">
    {activities.map(activity => (
      <ActivityItem key={activity.id} activity={activity} />
    ))}
  </div>
);

// components/UserDashboard.tsx - Main component
type UserDashboardProps = {
  user: User;
};

export const UserDashboard = ({ user }: UserDashboardProps) => (
  <div className="user-dashboard">
    <UserHeader user={user} />
    <UserStats user={user} />
    <UserActivity activities={user.activities} />
  </div>
);
```

## Rules for Component Props

### Extract Minimal Props

Only pass what each component needs:

```typescript
// ✅ Good - minimal props
<UserStats postsCount={user.posts.length} followersCount={user.followers.length} />

// ❌ Bad - passing entire object when only parts are needed
<UserStats user={user} />
```

### Make Components Reusable

Design for reusability from the start:

```typescript
// ✅ Good - reusable
type StatCardProps = {
    title: string;
    value: number;
    icon?: string;
    color?: "blue" | "green" | "red";
};

// ❌ Bad - too specific
type UserPostsCardProps = {
    user: User; // Too coupled to User
};
```

## Utility Extraction

Extract utility functions to appropriate files:

```typescript
// Before - mixed in component
const UserProfile = ({ user }: UserProfileProps) => {
  const formatUserName = (user: User) => {
    return `${user.firstName} ${user.lastName}`;
  };

  const calculateUserAge = (birthDate: string) => {
    return new Date().getFullYear() - new Date(birthDate).getFullYear();
  };

  return (
    <div>
      <h1>{formatUserName(user)}</h1>
      <p>Age: {calculateUserAge(user.birthDate)}</p>
    </div>
  );
};

// After - utilities extracted
// utils/user-utils.ts
export const formatUserName = (user: User): string =>
  `${user.firstName} ${user.lastName}`;

export const calculateUserAge = (birthDate: string): number =>
  new Date().getFullYear() - new Date(birthDate).getFullYear();

// components/UserProfile.tsx
import { formatUserName, calculateUserAge } from '../utils/user-utils';

export const UserProfile = ({ user }: UserProfileProps) => (
  <div>
    <h1>{formatUserName(user)}</h1>
    <p>Age: {calculateUserAge(user.birthDate)}</p>
  </div>
);
```

## Benefits

-   **Testability**: Each component can be tested in isolation
-   **Reusability**: Components can be used in different contexts
-   **Maintainability**: Changes are isolated to specific components
-   **Performance**: Smaller components can be optimized individually
-   **Developer Experience**: Easier to understand and navigate

## Anti-Patterns

-   **Over-extraction**: Creating components for every small piece of JSX
-   **Under-extraction**: Keeping large monolithic components
-   **Tight Coupling**: Components that depend too heavily on parent state
-   **Prop Drilling**: Passing props through many levels unnecessarily
