---
description:
globs:
alwaysApply: true
---
# Store Patterns

State management patterns and context provider requirements.

## Store Exception Rule

-   Stores have no line limit (complete state domains)
-   Must contain complete state domain
-   **Must be wrapped by React context provider**
-   **No global store access allowed**
-   Co-locate provider with store definition

## Required Store Structure

```typescript
// UserStore.tsx
import { createStore } from '@xstate/store';
import { createContext, useContext, ReactNode } from 'react';

// 1. Store definition (internal)
const userStore = createStore({
  // Store implementation
  users: [] as User[],
  selectedUser: null as User | null,
  isLoading: false,
}, {
  // Actions
  setUsers: (context, event: { users: User[] }) => ({
    ...context,
    users: event.users,
  }),
  selectUser: (context, event: { user: User }) => ({
    ...context,
    selectedUser: event.user,
  }),
});

// 2. Context creation
const UserStoreContext = createContext<typeof userStore | null>(null);

// 3. Provider component
type UserStoreProviderProps = {
  children: ReactNode;
};

export const UserStoreProvider = ({ children }: UserStoreProviderProps) => {
  return (
    <UserStoreContext.Provider value={userStore}>
      {children}
    </UserStoreContext.Provider>
  );
};

// 4. Hook for accessing store
export const useUserStore = () => {
  const context = useContext(UserStoreContext);
  if (!context) {
    throw new Error('useUserStore must be used within UserStoreProvider');
  }
  return context;
};

// 5. No direct store export
// ❌ export { userStore }; // BAD - allows global access
```

## Usage Pattern

```typescript
// App.tsx - Wrap with provider
const App = () => {
  return (
    <UserStoreProvider>
      <UserManagement />
    </UserStoreProvider>
  );
};

// UserManagement.tsx - Use via hook
const UserManagement = () => {
  const userStore = useUserStore();
  const users = userStore.useSelector(state => state.users);

  const handleAddUser = (user: User) => {
    userStore.send({ type: 'setUsers', users: [...users, user] });
  };

  return (
    <div>
      {users.map(user => <UserCard key={user.id} user={user} />)}
    </div>
  );
};
```

## Anti-Patterns

```typescript
// ❌ BAD - Direct global store access
export const userStore = createStore(/* ... */);

// ❌ BAD - Store without context provider
export const useUserStore = () => userStore;

// ❌ BAD - Missing error handling
export const useUserStore = () => {
    return useContext(UserStoreContext); // Could return null
};

// ❌ BAD - Store accessible outside React
window.userStore = userStore;
```

## Benefits

-   **Encapsulation**: Store only accessible through React context
-   **Type Safety**: Hook provides typed access to store
-   **Error Prevention**: Clear error messages for missing provider
-   **Testing**: Easy to provide mock store in tests
-   **Boundary Control**: Store scope controlled by provider placement

## Store Composition

For complex applications, compose multiple stores:

```typescript
// AppProviders.tsx
export const AppProviders = ({ children }: { children: ReactNode }) => {
  return (
    <UserStoreProvider>
      <NotificationStoreProvider>
        <ThemeStoreProvider>
          {children}
        </ThemeStoreProvider>
      </NotificationStoreProvider>
    </UserStoreProvider>
  );
};
```

## Testing Pattern

```typescript
// test-utils.tsx
export const createMockUserStore = (initialState?: Partial<UserState>) => {
  return createStore({
    users: [],
    selectedUser: null,
    isLoading: false,
    ...initialState,
  });
};

// UserComponent.test.tsx
const renderWithStore = (component: ReactElement, mockStore = createMockUserStore()) => {
  return render(
    <UserStoreContext.Provider value={mockStore}>
      {component}
    </UserStoreContext.Provider>
  );
};
```
