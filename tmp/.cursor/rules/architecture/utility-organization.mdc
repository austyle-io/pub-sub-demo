---
description:
globs:
alwaysApply: true
---
# Utility Organization

Rules for organizing utility functions by functional domain rather than technical type.

## Rules

-   Group utility functions by functional domain, not by technical type
-   Use descriptive file names that convey purpose
-   Keep related functions together
-   Prefer domain-specific files over generic utils

## Required Organization Pattern

```
utils/
├── data-utils.ts         # Data manipulation functions
├── validation-utils.ts   # Input validation functions
├── format-utils.ts       # Display formatting functions
├── api-utils.ts          # API/service functions
├── cache-utils.ts        # Caching functionality
├── date-utils.ts         # Date and time utilities
├── string-utils.ts       # String manipulation
└── array-utils.ts        # Array processing utilities
```

## Domain-Based Grouping Examples

### Data Utilities

```typescript
// utils/data-utils.ts
import { cloneDeep, groupBy, orderBy } from "lodash";

export const transformUserData = (rawUser: RawUser): User => {
    return {
        id: rawUser.user_id,
        name: `${rawUser.first_name} ${rawUser.last_name}`,
        email: rawUser.email_address,
        createdAt: new Date(rawUser.created_timestamp),
    };
};

export const groupUsersByRole = (users: User[]) => {
    return groupBy(users, "role");
};

export const sortUsersByName = (users: User[]) => {
    return orderBy(users, ["name"], ["asc"]);
};

export const mergeUserPreferences = (existing: UserPrefs, updates: Partial<UserPrefs>) => {
    return cloneDeep({ ...existing, ...updates });
};
```

### Validation Utilities

```typescript
// utils/validation-utils.ts
import { isString, isEmpty, isNil, isObject, isArray } from "lodash";

export const isValidEmail = (email: unknown): boolean => {
    if (!isString(email) || isEmpty(email)) return false;
    const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
    return emailRegex.test(email);
};

export const isValidPassword = (password: unknown): boolean => {
    if (!isString(password)) return false;
    return password.length >= 8 && /[A-Z]/.test(password) && /[a-z]/.test(password) && /[0-9]/.test(password);
};

export const isValidUserInput = (input: unknown): input is UserInput => {
    return (
        isObject(input) &&
        !isArray(input) &&
        !isNil(input) &&
        isString((input as any).name) &&
        isString((input as any).email) &&
        isString((input as any).password)
    );
};

export const validateUserInput = (input: unknown): ValidationResult => {
    const errors: string[] = [];

    if (!isValidUserInput(input)) {
        errors.push("Invalid input format");
        return { isValid: false, errors };
    }

    if (isEmpty(input.name.trim())) {
        errors.push("Name is required");
    }

    if (!isValidEmail(input.email)) {
        errors.push("Valid email is required");
    }

    if (!isValidPassword(input.password)) {
        errors.push("Password must be at least 8 characters with mixed case and numbers");
    }

    return {
        isValid: errors.length === 0,
        errors,
    };
};
```

### Format Utilities

```typescript
// utils/format-utils.ts
export const formatCurrency = (amount: number, currency = "USD"): string => {
    return new Intl.NumberFormat("en-US", {
        style: "currency",
        currency,
    }).format(amount);
};

// config/format-constants.ts
const DATE_FORMAT = {
    SHORT: "short",
    LONG: "long",
    RELATIVE: "relative",
} as const;

type DateFormat = (typeof DATE_FORMAT)[keyof typeof DATE_FORMAT];

// Lookup pattern instead of switch statement
const DATE_FORMATTERS: Record<DateFormat, (date: Date) => string> = {
    [DATE_FORMAT.SHORT]: (date) => date.toLocaleDateString(),
    [DATE_FORMAT.LONG]: (date) =>
        date.toLocaleDateString("en-US", {
            year: "numeric",
            month: "long",
            day: "numeric",
        }),
    [DATE_FORMAT.RELATIVE]: (date) => formatRelativeTime(date),
};

export const formatDate = (date: Date, format: DateFormat = DATE_FORMAT.SHORT): string => {
    const formatter = DATE_FORMATTERS[format];
    return formatter ? formatter(date) : DATE_FORMATTERS[DATE_FORMAT.SHORT](mdc:date);
};

export const formatFileSize = (bytes: number): string => {
    const units = ["B", "KB", "MB", "GB", "TB"];
    let size = bytes;
    let unitIndex = 0;

    while (size >= 1024 && unitIndex < units.length - 1) {
        size /= 1024;
        unitIndex++;
    }

    return `${Math.round(size * 100) / 100} ${units[unitIndex]}`;
};
```

### API Utilities

```typescript
// utils/api-utils.ts
import { debounce } from "lodash";

export const createApiClient = (baseUrl: string, defaultHeaders: Record<string, string> = {}) => {
    return {
        async get<T>(endpoint: string, headers?: Record<string, string>): Promise<T> {
            const response = await fetch(`${baseUrl}${endpoint}`, {
                method: "GET",
                headers: { ...defaultHeaders, ...headers },
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            return response.json();
        },

        async post<T>(endpoint: string, data: unknown, headers?: Record<string, string>): Promise<T> {
            const response = await fetch(`${baseUrl}${endpoint}`, {
                method: "POST",
                headers: {
                    "Content-Type": "application/json",
                    ...defaultHeaders,
                    ...headers,
                },
                body: JSON.stringify(data),
            });

            if (!response.ok) {
                throw new Error(`API Error: ${response.status}`);
            }

            return response.json();
        },
    };
};

export const debouncedApiCall = debounce(async (endpoint: string, callback: (data: any) => void) => {
    try {
        const data = await apiClient.get(endpoint);
        callback(data);
    } catch (error) {
        console.error("API call failed:", error);
    }
}, 300);
```

### Cache Utilities

```typescript
// utils/cache-utils.ts
export class MemoryCache<T> {
    private cache = new Map<string, { data: T; timestamp: number; ttl: number }>();

    set(key: string, data: T, ttl = 300000): void {
        // 5 minute default TTL
        this.cache.set(key, {
            data,
            timestamp: Date.now(),
            ttl,
        });
    }

    get(key: string): T | null {
        const entry = this.cache.get(key);

        if (!entry) {
            return null;
        }

        if (Date.now() - entry.timestamp > entry.ttl) {
            this.cache.delete(key);
            return null;
        }

        return entry.data;
    }

    clear(): void {
        this.cache.clear();
    }

    getStats() {
        return {
            size: this.cache.size,
            keys: Array.from(this.cache.keys()),
        };
    }
}

export const sessionCache = new MemoryCache<unknown>();

export const withCache = <T>(key: string, fetcher: () => Promise<T>, ttl?: number): Promise<T> => {
    const cached = sessionCache.get(key) as T;

    if (cached) {
        return Promise.resolve(cached);
    }

    return fetcher().then((data) => {
        sessionCache.set(key, data, ttl);
        return data;
    });
};
```

## Anti-Patterns

### ❌ Technical Grouping (Wrong)

```
utils/
├── arrays.ts        # Technical grouping
├── objects.ts       # Technical grouping
├── strings.ts       # Technical grouping
├── helpers.ts       # Too generic
├── utils.ts         # Too generic
└── misc.ts          # No clear purpose
```

### ❌ Mixed Concerns (Wrong)

```typescript
// utils/helpers.ts - BAD: Mixed concerns
export const formatCurrency = (amount: number) => {
    /* formatting */
};
export const validateEmail = (email: string) => {
    /* validation */
};
export const fetchUserData = (id: string) => {
    /* API call */
};
export const cacheResult = (key: string, data: any) => {
    /* caching */
};
```

## Benefits

-   **Predictable**: Easy to find utilities by their domain
-   **Maintainable**: Related functions grouped together
-   **Discoverable**: Clear file names indicate purpose
-   **Reusable**: Domain-focused utilities are more reusable
-   **Testable**: Easier to test domain-specific functionality
