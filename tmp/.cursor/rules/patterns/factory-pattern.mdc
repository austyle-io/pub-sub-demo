---
description:
globs:
alwaysApply: false
---
# Factory Pattern for Test Data

Comprehensive rules for creating and using factory functions to generate type-safe test data, avoiding readonly array issues with `as const`.

## Rules

- **Always use factory functions** for test data instead of inline objects with `as const`
- **Cast branded types once** in the factory, not at usage sites
- **Return mutable types** from factories to avoid readonly array assignment issues
- **Group factories by domain** in `__tests__/factories/` directories
- **Export all factories** through a barrel export (index.ts)
- **Use descriptive names** like `createUser`, `createMapConfig`, not `makeUser` or `getUserData`

## Factory Function Pattern

### Basic Factory Structure

```typescript
// ✅ CORRECT - Factory function pattern
export const createUser = (overrides?: Partial<User>): User => ({
    id: "user-1",
    name: "Test User",
    email: "test@example.com",
    role: "user" as UserRole,
    createdAt: new Date().toISOString(),
    ...overrides,
});

// ✅ CORRECT - Factory with specific variants
export const createAdminUser = (): User =>
    createUser({
        id: "admin-1",
        role: "admin" as UserRole,
    });

// ✅ CORRECT - Array factory
export const createUserArray = (count = 3): User[] => {
    return Array.from({ length: count }, (_, i) =>
        createUser({
            id: `user-${i}`,
            name: `User ${i}`,
        })
    );
};
```

### Branded Types in Factories

```typescript
import type { Id } from "../types";

// ✅ CORRECT - Cast branded types in factory
export const createMapLayer = (
    id: string,
    sourceId: string,
    overrides?: Partial<MapLayerConfig>
): MapLayerConfig => ({
    id: id as Id,  // Cast once here
    type: "circle",
    source: sourceId as Id,  // Cast once here
    paint: {
        "circle-radius": 6,
        "circle-color": "#007cbf",
    },
    ...overrides,
});

// Usage - no casting needed
const layer = createMapLayer("test-layer", "test-source");
```

## Anti-Patterns to Avoid

### ❌ Inline Test Data with as const

```typescript
// ❌ WRONG - Creates readonly array issues
const TEST_CONFIG = {
    sources: [] as const,
    layers: [] as const,
} as const;

// ❌ WRONG - Type assertion at usage
const config: MapConfig = {
    sources: [],
    layers: [{ id: "test" as Id }],  // Casting at usage
};
```

### ❌ Non-Factory Test Data Patterns

```typescript
// ❌ WRONG - Static test data
export const MOCK_USERS = [
    { id: "1", name: "User 1" },
    { id: "2", name: "User 2" },
] as const;

// ❌ WRONG - Function that doesn't follow factory pattern
export const getMockUser = () => {
    return { id: "1", name: "Test" };  // Same data every time
};
```

## Factory Organization

### Directory Structure

```
__tests__/
├── factories/
│   ├── index.ts          # Barrel export
│   ├── user.factory.ts   # User domain factories
│   ├── map.factory.ts    # Map domain factories
│   └── api.factory.ts    # API response factories
├── Component.test.tsx
└── Component.stories.tsx
```

### Barrel Export Pattern

```typescript
// factories/index.ts
export * from "./user.factory";
export * from "./map.factory";
export * from "./api.factory";

// Usage in tests
import { createUser, createMapConfig } from "./factories";
```

## Complex Factory Examples

### Nested Object Factory

```typescript
export const createApiResponse = <T>(
    data: T,
    overrides?: Partial<ApiResponse<T>>
): ApiResponse<T> => ({
    data,
    status: 200,
    message: "Success",
    timestamp: new Date().toISOString(),
    ...overrides,
});

// Usage with type safety
const userResponse = createApiResponse(createUser(), {
    status: 201,
    message: "User created",
});
```

### Factory with Relationships

```typescript
export const createPost = (
    authorId: string,
    overrides?: Partial<Post>
): Post => ({
    id: `post-${Date.now()}`,
    title: "Test Post",
    content: "Test content",
    authorId,
    createdAt: new Date().toISOString(),
    comments: [],
    ...overrides,
});

export const createPostWithComments = (
    authorId: string,
    commentCount = 3
): Post => {
    const post = createPost(authorId);
    const comments = Array.from({ length: commentCount }, (_, i) =>
        createComment(post.id, `commenter-${i}`)
    );

    return { ...post, comments };
};
```

### State Factory

```typescript
export const createAppState = (
    overrides?: Partial<AppState>
): AppState => ({
    user: null,
    isLoading: false,
    errors: [],
    config: createDefaultConfig(),
    ...overrides,
});

export const createAuthenticatedState = (
    user = createUser()
): AppState => createAppState({
    user,
    isLoading: false,
});
```

## Testing with Factories

### Unit Tests

```typescript
describe("UserList", () => {
    it("renders multiple users", () => {
        const users = createUserArray(5);
        render(<UserList users={users} />);

        expect(screen.getAllByRole("listitem")).toHaveLength(5);
    });

    it("handles admin users", () => {
        const admin = createAdminUser();
        render(<UserCard user={admin} />);

        expect(screen.getByText("Admin")).toBeInTheDocument();
    });
});
```

### Storybook Stories

```typescript
import { createUser, createUserArray } from "../factories";

export const SingleUser: Story = {
    args: {
        user: createUser({ name: "John Doe" }),
    },
};

export const MultipleUsers: Story = {
    args: {
        users: createUserArray(10),
    },
};
```

## Benefits

- **Type Safety**: Full TypeScript support without readonly issues
- **Flexibility**: Easy to create variations with overrides
- **Maintainability**: Single source of truth for test data structure
- **Reusability**: Factories can be shared across tests and stories
- **No Mock Data**: Follows no-mock-data-in-production rule
- **Branded Types**: Proper handling of branded types like `Id`

## Migration Checklist

When converting from `as const` patterns to factories:

1. [ ] Identify all `as const` test data
2. [ ] Create factory functions in `__tests__/factories/`
3. [ ] Replace inline test data with factory calls
4. [ ] Remove all type assertions at usage sites
5. [ ] Update imports to use factory functions
6. [ ] Add barrel export in `factories/index.ts`
7. [ ] Verify all tests still pass
